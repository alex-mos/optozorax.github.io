<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
      <title>optozorax.blog - типизация</title>
        <link>https://testzorax.github.io/</link>
        <description>Мои програмульки и результаты их работы</description>
        <generator>Zola</generator>
        <language>ru</language>
        <atom:link href="https://testzorax.github.io/tags/tipizatsiia/rss.xml" rel="self" type="application/rss+xml"/>
        <lastBuildDate>Sat, 20 Jun 2020 00:00:00 +0000</lastBuildDate>
        <item>
            <title>Float — это динамическая типизация на уровне процессора</title>
            <pubDate>Sat, 20 Jun 2020 00:00:00 +0000</pubDate>
            <link>https://testzorax.github.io/p/typed-float/</link>
            <guid>https://testzorax.github.io/p/typed-float/</guid>
            <description>&lt;h1 id=&quot;vvedenie&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#vvedenie&quot;&gt;#&lt;&#x2F;a&gt;Введение&lt;&#x2F;h1&gt;
&lt;p&gt;В этой статье предполагается что вы знакомы с языком Rust, и знаете что такое алгебраические типы данных (ADT).&lt;&#x2F;p&gt;
&lt;p&gt;Сравните эти два примера кода:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;js&quot; style=&quot;background-color:#f5f5f5;color:#1f1f1f;&quot; class=&quot;language-js &quot;&gt;&lt;code class=&quot;language-js&quot; data-lang=&quot;js&quot;&gt;&lt;span style=&quot;color:#668f14;&quot;&gt;function &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c23f31;&quot;&gt;something&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#5597d6;&quot;&gt;a&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#72ab00;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#72ab00;&quot;&gt;typeof &lt;&#x2F;span&gt;&lt;span style=&quot;color:#5597d6;&quot;&gt;a &lt;&#x2F;span&gt;&lt;span style=&quot;color:#72ab00;&quot;&gt;=== &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d07711;&quot;&gt;&amp;quot;number&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#72ab00;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#5597d6;&quot;&gt;a&lt;&#x2F;span&gt;&lt;span style=&quot;color:#72ab00;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b3933a;&quot;&gt;3 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#72ab00;&quot;&gt;+ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b3933a;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#72ab00;&quot;&gt;else if &lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#72ab00;&quot;&gt;typeof &lt;&#x2F;span&gt;&lt;span style=&quot;color:#5597d6;&quot;&gt;a &lt;&#x2F;span&gt;&lt;span style=&quot;color:#72ab00;&quot;&gt;=== &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d07711;&quot;&gt;&amp;quot;string&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#72ab00;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b3933a;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#f5f5f5;color:#1f1f1f;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#668f14;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c23f31;&quot;&gt;something&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#5597d6;&quot;&gt;a&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#668f14;&quot;&gt;f64&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#668f14;&quot;&gt;f64 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#72ab00;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; a.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b39f04;&quot;&gt;is_nan&lt;&#x2F;span&gt;&lt;span&gt;() {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b3933a;&quot;&gt;0.0
&lt;&#x2F;span&gt;&lt;span&gt;    } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#72ab00;&quot;&gt;else if !&lt;&#x2F;span&gt;&lt;span&gt;a.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b39f04;&quot;&gt;is_finite&lt;&#x2F;span&gt;&lt;span&gt;() {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b3933a;&quot;&gt;1.0
&lt;&#x2F;span&gt;&lt;span&gt;    } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#72ab00;&quot;&gt;else if&lt;&#x2F;span&gt;&lt;span&gt; a &lt;&#x2F;span&gt;&lt;span style=&quot;color:#72ab00;&quot;&gt;== &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b3933a;&quot;&gt;0.0 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b3933a;&quot;&gt;1.0
&lt;&#x2F;span&gt;&lt;span&gt;    } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#72ab00;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b3933a;&quot;&gt;1 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#72ab00;&quot;&gt;&#x2F;&lt;&#x2F;span&gt;&lt;span&gt; a.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b39f04;&quot;&gt;abs&lt;&#x2F;span&gt;&lt;span&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Казалось, бы, два совершенно разных языка, а код выглядит так одинаково: всё &lt;strong&gt;валидируется&lt;&#x2F;strong&gt; (кто не в теме, надо &lt;a href=&quot;https:&#x2F;&#x2F;habr.com&#x2F;ru&#x2F;post&#x2F;498042&#x2F;&quot;&gt;парсить, а не валидировать&lt;&#x2F;a&gt;). Да, всё дело в том, что вещественные числа - это, по сути, динамическая типизация на уровне процессора. У нас в переменной вещественного числа может храниться множество состояний, которые мы должны проверять, если хотим узнать что там хранится. Так же там присутствует неявное приведение типов из &amp;quot;разных&amp;quot; категорий, например &lt;code&gt;1.0 + NaN = NaN&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Что люди сделали с динамической типизацией в JavaScript? Они придумали TypeScript. И стало хорошо. Получается то же самое можно сделать с вещественными числами?&lt;&#x2F;p&gt;
&lt;h1 id=&quot;nan&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#nan&quot;&gt;#&lt;&#x2F;a&gt;NaN&lt;&#x2F;h1&gt;
&lt;p&gt;Самая базовая проблема вещественных чисел - это &lt;code&gt;NaN&lt;&#x2F;code&gt;. Он обладает очень противным свойством: не равен самому себе.&lt;&#x2F;p&gt;
&lt;p&gt;Из-за этого мы в Rust&#x27;е не можем хранить вещественные числа в дереве, сортировать массив с ними, то есть реализовывать трейты &lt;code&gt;Eq&lt;&#x2F;code&gt;, &lt;code&gt;Ord&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Если вытащить из вещественного числа &lt;code&gt;NaN&lt;&#x2F;code&gt;, то оно сразу становится хорошим. Схематически это можно обозначить так:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#f5f5f5;color:#1f1f1f;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#668f14;&quot;&gt;enum &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c23f31;&quot;&gt;Float &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    NaN,
&lt;&#x2F;span&gt;&lt;span&gt;    NotNanFloat(NotNanFloat),
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#668f14;&quot;&gt;enum &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c23f31;&quot;&gt;NotNanFloat &lt;&#x2F;span&gt;&lt;span&gt;{ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#7f8989;&quot;&gt;&#x2F;* ... *&#x2F; &lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#668f14;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;Eq &lt;&#x2F;span&gt;&lt;span style=&quot;color:#72ab00;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c23f31;&quot;&gt;NotNanFloat &lt;&#x2F;span&gt;&lt;span&gt;{ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#7f8989;&quot;&gt;&#x2F;* ... *&#x2F; &lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#668f14;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;Ord &lt;&#x2F;span&gt;&lt;span style=&quot;color:#72ab00;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c23f31;&quot;&gt;NotNanFloat &lt;&#x2F;span&gt;&lt;span&gt;{ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#7f8989;&quot;&gt;&#x2F;* ... *&#x2F; &lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;И мы можем записать в массиве, что храним только &lt;code&gt;NotNanFloat&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Когда я писал &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;optozorax&#x2F;confidence&quot;&gt;github:confidence&lt;&#x2F;a&gt;, мне очень не хватало возможности матчиться по такой структуре данных, или говорить что я принимаю только &lt;code&gt;NotNanFloat&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Правда, появляется проблема, что некоторые операции над &lt;code&gt;NotNanFloat&lt;&#x2F;code&gt; позволяют прийти к &lt;code&gt;NaN&lt;&#x2F;code&gt;, например: умножение бесконечности на ноль, деление на ноль. Получается, нам после любых арифметических вычислений нужно приводить тип из более широкого &lt;code&gt;Float&lt;&#x2F;code&gt; обратно к &lt;code&gt;NotNanFloat&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#f5f5f5;color:#1f1f1f;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#668f14;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; a: NotNanFloat &lt;&#x2F;span&gt;&lt;span style=&quot;color:#72ab00;&quot;&gt;= ...&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#668f14;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; b: NotNanFloat &lt;&#x2F;span&gt;&lt;span style=&quot;color:#72ab00;&quot;&gt;= ...&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#668f14;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; c: Float &lt;&#x2F;span&gt;&lt;span style=&quot;color:#72ab00;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; a &lt;&#x2F;span&gt;&lt;span style=&quot;color:#72ab00;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt; b &lt;&#x2F;span&gt;&lt;span style=&quot;color:#72ab00;&quot;&gt;&#x2F; &lt;&#x2F;span&gt;&lt;span&gt;(a &lt;&#x2F;span&gt;&lt;span style=&quot;color:#72ab00;&quot;&gt;+&lt;&#x2F;span&gt;&lt;span&gt; b);
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#668f14;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; d: NotNanFloat &lt;&#x2F;span&gt;&lt;span style=&quot;color:#72ab00;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; c.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b39f04;&quot;&gt;try_into&lt;&#x2F;span&gt;&lt;span&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b39f04;&quot;&gt;unwrap&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;С одной стороны это даже хорошо, потому что мы не будем хранить фигню у себя в массивах, и в конце не получим что у нас огромная матрица перемножалась 100 раз с &lt;code&gt;NaN&lt;&#x2F;code&gt;&#x27;ами, а получим ошибку намного раньше.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;prodolzhenie-bezumiia&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#prodolzhenie-bezumiia&quot;&gt;#&lt;&#x2F;a&gt;Продолжение безумия&lt;&#x2F;h1&gt;
&lt;p&gt;Можно пойти дальше и ещё сильнее разделить вещественные числа:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#f5f5f5;color:#1f1f1f;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#668f14;&quot;&gt;enum &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c23f31;&quot;&gt;NotNanFloat &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    InfiniteFloat(InfiniteFloat),
&lt;&#x2F;span&gt;&lt;span&gt;    FiniteFloat(FiniteFloat),
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#668f14;&quot;&gt;enum &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c23f31;&quot;&gt;InfiniteFloat &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    Negative,
&lt;&#x2F;span&gt;&lt;span&gt;    Positive,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#668f14;&quot;&gt;enum &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c23f31;&quot;&gt;FiniteFloat &lt;&#x2F;span&gt;&lt;span&gt;{ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#7f8989;&quot;&gt;&#x2F;* ... *&#x2F; &lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Но в этом уже нет такой серьёзной причины как в отделении от &lt;code&gt;NaN&lt;&#x2F;code&gt;&#x27;а. Такое разделение можно использовать для более чёткого контроля типов данных на этапе компиляции.&lt;&#x2F;p&gt;
&lt;p&gt;Например, можно создать тип &lt;code&gt;FloatFrom0ToInf&lt;&#x2F;code&gt;, который содержит все положительные числа и включая ноль. И затем сказать что &lt;code&gt;fn div_one(down: FloatFrom0ToInf) -&amp;gt; FloatFrom0ToInf&lt;&#x2F;code&gt;. Ну и вообще рассчитать все операции друг из друга, и записать это на системах типов.&lt;&#x2F;p&gt;
&lt;p&gt;Либо же &lt;code&gt;NotNanFloat&lt;&#x2F;code&gt; можно расписать так:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#f5f5f5;color:#1f1f1f;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#668f14;&quot;&gt;enum &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c23f31;&quot;&gt;NotNanFloat &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    PositiveFloat(PositiveFloat),
&lt;&#x2F;span&gt;&lt;span&gt;    NegativeFloat(NegativeFloat),
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#668f14;&quot;&gt;enum &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c23f31;&quot;&gt;PositiveFloat &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    Infinity,
&lt;&#x2F;span&gt;&lt;span&gt;    FinitePositiveFloat(FinitePositiveFloat),
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#668f14;&quot;&gt;enum &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c23f31;&quot;&gt;FinitePositiveFloat &lt;&#x2F;span&gt;&lt;span&gt;{ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#7f8989;&quot;&gt;&#x2F;* ... *&#x2F; &lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Здесь можно сделать метод: &lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#f5f5f5;color:#1f1f1f;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#668f14;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c23f31;&quot;&gt;mul&lt;&#x2F;span&gt;&lt;span&gt;(PositiveFiniteFloat, PositiveFiniteFloat) -&amp;gt; PositiveFloat;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Или надо отделить ноль от всего остального, и можно получить деление, которое не должно вызывать &lt;code&gt;NaN&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#f5f5f5;color:#1f1f1f;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#668f14;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c23f31;&quot;&gt;div&lt;&#x2F;span&gt;&lt;span&gt;(FiniteFloat, NonZeroFiniteFloat) -&amp;gt; NonZeroFiniteFloat;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;А ещё можно иметь крутые сообщения об ошибках, когда ты пытаешься преобразовать более широкий тип к более маленькому:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#f5f5f5;color:#1f1f1f;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#668f14;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; a: Float &lt;&#x2F;span&gt;&lt;span style=&quot;color:#72ab00;&quot;&gt;= -&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b3933a;&quot;&gt;1.2&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#668f14;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; b: PositiveFiniteFloat &lt;&#x2F;span&gt;&lt;span style=&quot;color:#72ab00;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; a.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b39f04;&quot;&gt;float_unwrap&lt;&#x2F;span&gt;&lt;span&gt;(); &lt;&#x2F;span&gt;&lt;span style=&quot;color:#7f8989;&quot;&gt;&#x2F;&#x2F; &amp;quot;Can&amp;#39;t convert negative float `-1.2` to positive number in line N&amp;quot;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Такие типы могли бы быть очень удобны во всяких библиотечных функциях. Например, функция расчёта площади треугольника по трём сторонам, которая принимает только конечные положительные числа, чтобы не &lt;strong&gt;валидировать&lt;&#x2F;strong&gt; их внутри:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#f5f5f5;color:#1f1f1f;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#668f14;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c23f31;&quot;&gt;triangle_area&lt;&#x2F;span&gt;&lt;span&gt;(
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#5597d6;&quot;&gt;a&lt;&#x2F;span&gt;&lt;span&gt;: PositiveNonZeroFiniteFloat, 
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#5597d6;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span&gt;: PositiveNonZeroFiniteFloat, 
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#5597d6;&quot;&gt;c&lt;&#x2F;span&gt;&lt;span&gt;: PositiveNonZeroFiniteFloat,
&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a2a001;&quot;&gt;Option&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;PositiveNonZeroFiniteFloat&amp;gt; { &lt;&#x2F;span&gt;&lt;span style=&quot;color:#7f8989;&quot;&gt;&#x2F;* ... *&#x2F; &lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#7f8989;&quot;&gt;&#x2F;&#x2F; В этой функции возвращается `Option&amp;lt;_&amp;gt;`, потому что в процессе вычислений может возникнуть бесконечность.
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;И таких способов расписать &lt;code&gt;NotNanFloat&lt;&#x2F;code&gt; существует очень много. Для этого, бы, наверное, в Rust пришлось создать целую языковую конструкцию &lt;code&gt;safe union&lt;&#x2F;code&gt;, которая позволяет переключаться между этими представлениями &lt;code&gt;Float&lt;&#x2F;code&gt;, потому что они абсолютно эквивалентны.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;to-zhe-samoe-no-na-tipakh&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#to-zhe-samoe-no-na-tipakh&quot;&gt;#&lt;&#x2F;a&gt;То же самое, но на типах&lt;&#x2F;h1&gt;
&lt;p&gt;Или это разделение можно записывать по-другому:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#f5f5f5;color:#1f1f1f;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#668f14;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c23f31;&quot;&gt;Yes&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#668f14;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c23f31;&quot;&gt;No&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#668f14;&quot;&gt;trait &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c23f31;&quot;&gt;IsFloatParameter &lt;&#x2F;span&gt;&lt;span&gt;{}
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#668f14;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;IsFloatParameter &lt;&#x2F;span&gt;&lt;span style=&quot;color:#72ab00;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c23f31;&quot;&gt;Yes&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c23f31;&quot;&gt;impl IsFloatParameter for No&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c23f31;&quot;&gt;struct Float&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;
&lt;&#x2F;span&gt;&lt;span&gt;    HasNan: IsFloatParameter,
&lt;&#x2F;span&gt;&lt;span&gt;    HasNegativeInfinity: IsFloatParameter,
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    HasNegativeFrom1: IsFloatParameter,
&lt;&#x2F;span&gt;&lt;span&gt;    HasNegative1: IsFloatParameter,
&lt;&#x2F;span&gt;&lt;span&gt;    HasNegativeFrom0To1: IsFloatParameter,
&lt;&#x2F;span&gt;&lt;span&gt;    HasNegative0: IsFloatParameter,
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    HasPositive0: IsFloatParameter,
&lt;&#x2F;span&gt;&lt;span&gt;    HasPositiveFrom0To1: IsFloatParameter,
&lt;&#x2F;span&gt;&lt;span&gt;    HasPositive1: IsFloatParameter,
&lt;&#x2F;span&gt;&lt;span&gt;    HasPositiveFrom1: IsFloatParameter,
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    HasPositiveInfinity: IsFloatParameter,
&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c23f31;&quot;&gt;f64&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c23f31;&quot;&gt;type NotNanFloat&lt;&#x2F;span&gt;&lt;span&gt; = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c23f31;&quot;&gt;Float&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;
&lt;&#x2F;span&gt;&lt;span&gt;    No, 
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    Yes, 
&lt;&#x2F;span&gt;&lt;span&gt;    Yes, Yes, Yes, Yes, 
&lt;&#x2F;span&gt;&lt;span&gt;    Yes, Yes, Yes, Yes, 
&lt;&#x2F;span&gt;&lt;span&gt;    Yes,
&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Но в таком случае теряется возможность матчиться по структуре данных, чтобы получить нужный промежуток. Не знаю что лучше.&lt;&#x2F;p&gt;
&lt;p&gt;Для подобного представления очень пригодятся умения программировать сложные вычисления на типах данных, чтобы автоматически получать все возможные преобразования для всех возможных комбинаций вещественных чисел.&lt;&#x2F;p&gt;
&lt;p&gt;Если же делать это вручную, то потребуется очень много кода. Вероятно, эту задачу было бы логичнее решать на зависимых типах? Или нужна новая, более сильная абстракция, чем ADT?&lt;&#x2F;p&gt;
&lt;h1 id=&quot;podderzhka-ot-kompiliatora&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#podderzhka-ot-kompiliatora&quot;&gt;#&lt;&#x2F;a&gt;Поддержка от компилятора&lt;&#x2F;h1&gt;
&lt;p&gt;Ещё, если такая система будет существовать, например, на Rust, то она должна поддерживаться со стороны компилятора аналогично &lt;code&gt;NonNull&lt;&#x2F;code&gt;, чтобы паттерн-матчинг по флоату раскрывался в максимально эффективные ассемблерные команды проверки, и чтобы хранение такого флоата в enum&#x27;ах &lt;code&gt;PositiveFloat&lt;&#x2F;code&gt;, &lt;code&gt;NotNanFloat&lt;&#x2F;code&gt; не тратило лишней памяти.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;zakliuchenie&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#zakliuchenie&quot;&gt;#&lt;&#x2F;a&gt;Заключение&lt;&#x2F;h1&gt;
&lt;p&gt;Наверное, поэтому даже в языках со статической типизацией, столько страданий приносят вещественные числа со своими бесконечностями и &lt;code&gt;NaN&lt;&#x2F;code&gt;&#x27;ами? Может быть, с этими типами данных, станет немного проще жить? Не знаю. Это лишь идея, возникающая на почве статической типизации головного мозга.&lt;&#x2F;p&gt;
&lt;p&gt;Динамическая типизация в JS легко сводится к статической типизации, потому что с логической точки зрения никакие операции над &lt;code&gt;int&lt;&#x2F;code&gt; не должны приводить к случайному возникновению &lt;code&gt;string&lt;&#x2F;code&gt;, а в вещественных числах всё сложнее, там все значения между собой очень сильно связаны, и вот простое сложение двух конечных чисел может дать бесконечность, а отношение двух конечных чисел может дать &lt;code&gt;NaN&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Надеюсь эта идея вдохновила вас.&lt;&#x2F;p&gt;
&lt;p&gt;А если хочется &lt;code&gt;NotNanFloat&lt;&#x2F;code&gt; иметь у себя в коде на Rust, то можно искать крейт по ключевым словам: &lt;code&gt;ordered float&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
</description>
        </item>
    </channel>
</rss>
