<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
      <title>optozorax.blog - обозначения</title>
        <link>https://testzorax.github.io/</link>
        <description>Мои програмульки и результаты их работы</description>
        <generator>Zola</generator>
        <language>ru</language>
        <atom:link href="https://testzorax.github.io/tags/oboznacheniia/rss.xml" rel="self" type="application/rss+xml"/>
        <lastBuildDate>Wed, 26 Aug 2020 00:00:00 +0000</lastBuildDate>
        <item>
            <title>5-бальная шкала оценки неверна</title>
            <pubDate>Wed, 26 Aug 2020 00:00:00 +0000</pubDate>
            <link>https://testzorax.github.io/p/5-point-ratings-are-wrong/</link>
            <guid>https://testzorax.github.io/p/5-point-ratings-are-wrong/</guid>
            <description>&lt;h1 id=&quot;konflikt&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#konflikt&quot;&gt;#&lt;&#x2F;a&gt;Конфликт&lt;&#x2F;h1&gt;
&lt;p&gt;На данный пост меня вдохновило следующее сообщение: &lt;&#x2F;p&gt;
&lt;script async src=&quot;https:&#x2F;&#x2F;telegram.org&#x2F;js&#x2F;telegram-widget.js?15&quot; data-telegram-post=&quot;klavaorgwork&amp;#x2F;159174&quot; data-width=&quot;100%&quot;&gt;&lt;&#x2F;script&gt;
&lt;p&gt;В нём чувак говорит, что оценка &lt;code&gt;3&lt;&#x2F;code&gt; - это оценка &amp;quot;удовлетворительно&amp;quot;, когда сервис работает как полагается. &lt;code&gt;4&lt;&#x2F;code&gt; он ставит, когда есть что-то действительно хорошее. И тут я прозрел, что всю жизнь считал, что оценку &lt;code&gt;3&lt;&#x2F;code&gt; надо ставить за плохую работу. Поэтому по умолчанию ставил &lt;code&gt;5&lt;&#x2F;code&gt; звёзд, а если что-то работало нехорошо - ставил оценку ниже, в зависимости от того, насколько плохо. То есть для меня оценка &lt;code&gt;5&lt;&#x2F;code&gt; была аналогом &amp;quot;удовлетворительно&amp;quot;. И, думаю, я не один такой. Наше понимание этих оценок сломала школьная система, которая говорит, что на &lt;code&gt;3&lt;&#x2F;code&gt; нельзя учиться, истина только в &lt;code&gt;4&lt;&#x2F;code&gt;, а лучше в &lt;code&gt;5&lt;&#x2F;code&gt;. &lt;&#x2F;p&gt;
&lt;p&gt;Мне кажется, эта проблема не только из-за школы, но ещё сам способ задания оценок неверен: он противоречит интуиции. Итак, у нас практически везде предлагается ставить оценку либо от &lt;code&gt;1&lt;&#x2F;code&gt; до &lt;code&gt;5&lt;&#x2F;code&gt;, либо от &lt;code&gt;0&lt;&#x2F;code&gt; до &lt;code&gt;10&lt;&#x2F;code&gt;. Первая очевидная проблема этих оценок: они все состоят из положительных чисел. Нам предлагается оценивать что-то только степенью хорошести. То, что &amp;quot;хорошо&amp;quot; на &lt;code&gt;1&lt;&#x2F;code&gt; из &lt;code&gt;5&lt;&#x2F;code&gt;, означает на самом деле &amp;quot;плохо&amp;quot; - это контринтуитивно.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;predlozhenie&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#predlozhenie&quot;&gt;#&lt;&#x2F;a&gt;Предложение&lt;&#x2F;h1&gt;
&lt;p&gt;&amp;quot;Хорошо&amp;quot; надо оценивать положительными числами, а &amp;quot;плохо&amp;quot; - отрицательными. Поэтому система оценки должна быть в целых числах от &lt;code&gt;-2&lt;&#x2F;code&gt; до &lt;code&gt;+2&lt;&#x2F;code&gt;, где оценка &lt;code&gt;0&lt;&#x2F;code&gt; будет считаться нейтральной, &amp;quot;удовлетворительно&amp;quot;. &lt;code&gt;±2&lt;&#x2F;code&gt; будет считаться как максимальная степень хорошего и плохого. &lt;code&gt;+1&lt;&#x2F;code&gt; должно стать оценкой для обозначения чего-то достаточно хорошего, чтобы не быть нейтральным, но ещё не самое лучшее, то есть промежуточное. Больше не нужно промежуточных, иначе будет слишком сложно выбрать.&lt;&#x2F;p&gt;
&lt;p&gt;Я предлагаю называть это &lt;em&gt;симметричной шкалой оценки&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Помимо неинтуитивности, у пятибальной шкалы существует такое наследие, как идеология. Согласно этой идеологии любая оценка ниже &lt;code&gt;5&lt;&#x2F;code&gt; считается плохой и никто не хочет получать &lt;code&gt;3&lt;&#x2F;code&gt;. То есть &amp;quot;удовлетворительно&amp;quot; - это &amp;quot;плохо&amp;quot;, как бы противоречиво это не звучало. В школах же оценка &lt;code&gt;5&lt;&#x2F;code&gt; считается достигнутой, когда ты выполнил все задания. Например, на контрольной ты решил все задачи - значит ты получаешь &lt;code&gt;5&lt;&#x2F;code&gt;. Оценка &lt;code&gt;5&lt;&#x2F;code&gt; - это не самая лучшая оценка, это просто когда ты всё решил. Выше нету, существует только ниже. Если получил &lt;code&gt;4&lt;&#x2F;code&gt; или &lt;code&gt;3&lt;&#x2F;code&gt;, то ты считаешься ущербным, потому что не сделал все задания. Видимо поэтому я по умолчанию всем приложениям ставил &lt;code&gt;5&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Ещё одна проблема любой положительной оценки - это то, что её промежуточные значения можно трактовать различным образом, и это трактование может отличаться от человека к человеку (10-бальная шкала в этом плане ещё хуже). Симметричную же шкалу трактовать иным образом очень сложно: там чётко обозначено понятие нейтралитета, негативного, позитивного и максимального.&lt;&#x2F;p&gt;
&lt;p&gt;С приходом новой шкалы должна прийти и новая идеология. Во-первых, все должны перестать гнаться за максимальной оценкой, социально допустимой нормой должен стать &lt;code&gt;0&lt;&#x2F;code&gt;. Должно быть нормально и не позорно делать что-то на &lt;code&gt;0&lt;&#x2F;code&gt; баллов. Аналогично в школе должно стать абсолютно нормально учиться на &lt;code&gt;0&lt;&#x2F;code&gt;, этой оценкой должен быть минимально необходимый минимум. Во-вторых, раз &lt;code&gt;0&lt;&#x2F;code&gt; стал нормальной оценкой, контрольные должны быть переделаны. Контрольные теперь не могут давать &lt;code&gt;+2&lt;&#x2F;code&gt; балла за полное их решение, они должны содержать различные секции: необходимое к решению (полное решение их даёт &lt;code&gt;0&lt;&#x2F;code&gt;) и дополнительные задания, которые уже позволяют показать, что вы умнее необходимого минимума. Для получения оценки &lt;code&gt;+2&lt;&#x2F;code&gt; должны даваться задачи, по сложности сопоставимые с профильными лицеями или олимпиадами. Так у школ появится возможность оценивать сверхпреуспевающих учеников, а не просто тех, кто упёрся в стенку &lt;code&gt;5&lt;&#x2F;code&gt; баллов.&lt;&#x2F;p&gt;
&lt;p&gt;Я считаю, что все шкалы оценки должны стать симметричными. Не только в школах, но ещё и в магазинах приложений, кинопоиске, imdb итд.&lt;&#x2F;p&gt;
&lt;p&gt;В целом, для разных целей шкалу можно расширить до &lt;code&gt;[-5, 5]&lt;&#x2F;code&gt; - главное, чтобы шкала оставалась симметричной и сохранялись все остальные принципы данной шкалы.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;kritika-ot-drugikh&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#kritika-ot-drugikh&quot;&gt;#&lt;&#x2F;a&gt;Критика от других&lt;&#x2F;h1&gt;
&lt;p&gt;На эту тему советую ещё заценить статью моего друга: &lt;a href=&quot;https:&#x2F;&#x2F;telegra.ph&#x2F;steloj-10-20&quot;&gt;Бесит! 10 звёзд.&lt;&#x2F;a&gt;, или она же в &lt;a href=&quot;https:&#x2F;&#x2F;t.me&#x2F;bpblog&#x2F;111&quot;&gt;телеге&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;А ещё я погуглил про пятибальную шкалу, и на каждом углу говорят, что она плохая и в школах надо её заменить другой положительно определённой шкалой: 10, 12, 15 😂 ИМХО, без отрицательных чисел, а особенно нуля, это будет лишь полумерой.&lt;&#x2F;p&gt;
&lt;p&gt;Ещё есть отличная &lt;a href=&quot;https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;gaming&#x2F;comments&#x2F;ky7lqq&#x2F;how_gamers_see_review_scores_now&#x2F;&quot;&gt;иллюстрация с рэддита&lt;&#x2F;a&gt; о том, как геймеры видят оценки игр:&lt;&#x2F;p&gt;
&lt;div class=&quot;magnifier-container img-one&quot;&gt;
&lt;img
    class=&quot;not-default full-screen-img&quot;
    width=&quot;1280&quot;
    height=&quot;658&quot;
    src=&quot;&amp;#x2F;processed_images&amp;#x2F;e6bf7399ba58953300.webp&quot; 
    onclick=&quot;full_screen(&#x27;gamer-marks.jpg&#x27;)&quot;
    onauxclick=&quot;full_screen_new_page(&#x27;gamer-marks.jpg&#x27;)&quot;&gt;
&lt;div class=&quot;magnifier-display&quot;&gt;
&lt;img class=&quot;magnifier&quot; src=&quot;&#x2F;ico&#x2F;magnifier.svg&quot;&gt;&lt;div class=&quot;magnifier-info&quot;&gt;×1.4&lt;br&gt;jpg&lt;&#x2F;div&gt;
&lt;&#x2F;div&gt;
&lt;&#x2F;div&gt;</description>
        </item>
        <item>
            <title>Произвольная нейросеть</title>
            <pubDate>Mon, 06 Jan 2020 00:00:00 +0000</pubDate>
            <link>https://testzorax.github.io/p/arbitrary-nn/</link>
            <guid>https://testzorax.github.io/p/arbitrary-nn/</guid>
            <description>&lt;h1 id=&quot;vvedenie&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#vvedenie&quot;&gt;#&lt;&#x2F;a&gt;Введение&lt;&#x2F;h1&gt;
&lt;p&gt;У вас не возникало ощущения что все текущие нейросети какие-то слишком линейные? Посмотрим, например, на перцептрон:&lt;&#x2F;p&gt;
&lt;figure&gt;
&lt;div class=&quot;magnifier-container img-one&quot;&gt;
&lt;img
    class=&quot;not-default full-screen-img&quot;
    width=&quot;395&quot;
    height=&quot;354&quot;
    src=&quot;&amp;#x2F;processed_images&amp;#x2F;5faa13a2b78bbd8600.webp&quot; 
    onclick=&quot;full_screen(&#x27;perceptron.png&#x27;)&quot;
    onauxclick=&quot;full_screen_new_page(&#x27;perceptron.png&#x27;)&quot;&gt;
&lt;div class=&quot;magnifier-display&quot;&gt;
&lt;img class=&quot;magnifier&quot; src=&quot;&#x2F;ico&#x2F;magnifier.svg&quot;&gt;&lt;div class=&quot;magnifier-info&quot;&gt;×1&lt;br&gt;png&lt;&#x2F;div&gt;
&lt;&#x2F;div&gt;
&lt;&#x2F;div&gt;
&lt;figcaption&gt;&lt;a href=&quot;https:&#x2F;&#x2F;ru.wikipedia.org&#x2F;wiki&#x2F;%D0%9F%D0%B5%D1%80%D1%86%D0%B5%D0%BF%D1%82%D1%80%D0%BE%D0%BD#&#x2F;media&#x2F;%D0%A4%D0%B0%D0%B9%D0%BB:Perceptron-ru.svg&quot;&gt;Источник&lt;&#x2F;a&gt;&lt;&#x2F;figcaption&gt;
&lt;&#x2F;figure&gt;
&lt;p&gt;Или на многослойную нейронную сеть:&lt;&#x2F;p&gt;
&lt;figure&gt;
&lt;div class=&quot;magnifier-container img-one&quot;&gt;
&lt;img
    class=&quot;not-default full-screen-img&quot;
    width=&quot;958&quot;
    height=&quot;455&quot;
    src=&quot;&amp;#x2F;processed_images&amp;#x2F;87116efccecb22a700.webp&quot; 
    onclick=&quot;full_screen(&#x27;multilayered.png&#x27;)&quot;
    onauxclick=&quot;full_screen_new_page(&#x27;multilayered.png&#x27;)&quot;&gt;
&lt;div class=&quot;magnifier-display&quot;&gt;
&lt;img class=&quot;magnifier&quot; src=&quot;&#x2F;ico&#x2F;magnifier.svg&quot;&gt;&lt;div class=&quot;magnifier-info&quot;&gt;×1&lt;br&gt;png&lt;&#x2F;div&gt;
&lt;&#x2F;div&gt;
&lt;&#x2F;div&gt;
&lt;figcaption&gt;&lt;a href=&quot;https:&#x2F;&#x2F;ru.wikipedia.org&#x2F;wiki&#x2F;%D0%9F%D0%B5%D1%80%D1%86%D0%B5%D0%BF%D1%82%D1%80%D0%BE%D0%BD#&#x2F;media&#x2F;%D0%A4%D0%B0%D0%B9%D0%BB:Neuro.PNG&quot;&gt;Источник&lt;&#x2F;a&gt;&lt;&#x2F;figcaption&gt;
&lt;&#x2F;figure&gt;
&lt;p&gt;Когда я только изучал эту тему, у меня была такая мысль:&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;Почему в них сигнал распространяется только в направлении слева-направо? Где циклы? Как без циклов возможны сложные вычисления?&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;Но на самом деле нейросети и не обязаны быть произвольными. Уже в таком виде они справляются с большим количеством задач. &lt;&#x2F;p&gt;
&lt;p&gt;Кстати, благодаря этой линейнойсти мы можем выжимать максимум из наших текущих вычислительных мощностей, используя очень большие нейросети. На них сигнал распространяется без всяких циклов, а значит это быстрее вычислять. &lt;&#x2F;p&gt;
&lt;p&gt;Да и для таких нейросетей придумали в своё время алгоритм обратного распространения ошибки.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;primer-proizvol-noi-neiroseti&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#primer-proizvol-noi-neiroseti&quot;&gt;#&lt;&#x2F;a&gt;Пример произвольной нейросети&lt;&#x2F;h1&gt;
&lt;p&gt;Не знаю откуда мы все это берём, но мы точно знаем, что в мозгу не могут быть такие однонаправленные связи, там полюбому должны присутсововать циклы и прочие очень сложные штуки. Нейросеть в нашем мозгу должна выглядеть примерно так:&lt;&#x2F;p&gt;
&lt;div class=&quot;magnifier-container img-one&quot;&gt;
&lt;img
    class=&quot;not-default full-screen-img&quot;
    width=&quot;932&quot;
    height=&quot;482&quot;
    src=&quot;&amp;#x2F;processed_images&amp;#x2F;16889bdb07c4ab4a00.webp&quot; 
    onclick=&quot;full_screen(&#x27;arbitrary_nn.png&#x27;)&quot;
    onauxclick=&quot;full_screen_new_page(&#x27;arbitrary_nn.png&#x27;)&quot;&gt;
&lt;div class=&quot;magnifier-display&quot;&gt;
&lt;img class=&quot;magnifier&quot; src=&quot;&#x2F;ico&#x2F;magnifier.svg&quot;&gt;&lt;div class=&quot;magnifier-info&quot;&gt;×1&lt;br&gt;png&lt;&#x2F;div&gt;
&lt;&#x2F;div&gt;
&lt;&#x2F;div&gt;
&lt;p&gt;То есть как просто простой направленный граф без всяких ограничений.&lt;&#x2F;p&gt;
&lt;p&gt;Очевидно, что такая нейросеть должна обладать возможность что-то &amp;quot;запоминать&amp;quot; на краткосрочный период, делать цикличные движения. Такая нейросеть идеально подходит для использования в агентах внутри симуляций.&lt;&#x2F;p&gt;
&lt;p&gt;Если мы симулируем агента в какой-то среде, то мы должны напрямую симулировать процесс &amp;quot;движения сигнала&amp;quot;, задавать какие-то ограничения по количество этих передвижений сигнала для одного шага, накапливать результат на красных выходных нейронах и что-то подобное.&lt;&#x2F;p&gt;
&lt;p&gt;Я не стал на этом изображении расставлять веса нейронных связей, чтобы не загромождать изображение, но по факту они там должны быть.&lt;&#x2F;p&gt;
&lt;p&gt;Кстати, произвольная нейросеть была использована в этом видео:&lt;&#x2F;p&gt;
&lt;center&gt;
&lt;iframe src=&quot;https:&#x2F;&#x2F;www.youtube-nocookie.com&#x2F;embed&#x2F;5lJuEW-5vr8&quot; title=&quot;YouTube video player&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture&quot; allowfullscreen style=&quot;width: 560px; height: 315px;&quot;&gt;&lt;&#x2F;iframe&gt;
&lt;&#x2F;center&gt;
&lt;p&gt;И ведь действительно, интуитивно очевидно, что для симуляции агентов, пытающихся развиваться в виртуальном или реальном мире, надо использовать максимально общий класс нейросетей - произвольные! &lt;&#x2F;p&gt;
&lt;p&gt;Меня очень долго волновала проблема, почему нигде в интернете я не могу найти как учёные используют такие прозвольные нейросети, неужто целая категория нейронных сетей берёт и простаивает??? Значит могу прийти я со своими произвольными нейросетями и взорвать науку?!&lt;&#x2F;p&gt;
&lt;p&gt;К сожалению, нет.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;rekkurentnaia-neironnaia-set&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#rekkurentnaia-neironnaia-set&quot;&gt;#&lt;&#x2F;a&gt;Реккурентная нейронная сеть&lt;&#x2F;h1&gt;
&lt;p&gt;Чтобы понять дальнейшее повествование, надо понять что такое реккурентная нейросеть. Для ознакомления рекомендую это видео:&lt;&#x2F;p&gt;
&lt;center&gt;
&lt;iframe src=&quot;https:&#x2F;&#x2F;www.youtube-nocookie.com&#x2F;embed&#x2F;ADcu9rWK_3I&quot; title=&quot;YouTube video player&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture&quot; allowfullscreen style=&quot;width: 560px; height: 315px;&quot;&gt;&lt;&#x2F;iframe&gt;
&lt;&#x2F;center&gt;
&lt;p&gt;Тут расскажут не только как это работает в общем виде, но ещё и расскажут про одну очень хитрую современную архитектуру LSTM.&lt;&#x2F;p&gt;
&lt;p&gt;Ну, или можете это проигнорировать (всё-таки час идёт) и просто попытаться понять суть из контекста.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;svodim-proizvol-nuiu-neiroset-k-rekkurentnoi&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#svodim-proizvol-nuiu-neiroset-k-rekkurentnoi&quot;&gt;#&lt;&#x2F;a&gt;Сводим произвольную нейросеть к реккурентной&lt;&#x2F;h1&gt;
&lt;p&gt;Сначала пронумеруем все нейроны.&lt;&#x2F;p&gt;
&lt;div class=&quot;magnifier-container img-one&quot;&gt;
&lt;img
    class=&quot;not-default full-screen-img&quot;
    width=&quot;931&quot;
    height=&quot;481&quot;
    src=&quot;&amp;#x2F;processed_images&amp;#x2F;d21fc5fc32af109600.webp&quot; 
    onclick=&quot;full_screen(&#x27;arbitrary_nn_enumerated.png&#x27;)&quot;
    onauxclick=&quot;full_screen_new_page(&#x27;arbitrary_nn_enumerated.png&#x27;)&quot;&gt;
&lt;div class=&quot;magnifier-display&quot;&gt;
&lt;img class=&quot;magnifier&quot; src=&quot;&#x2F;ico&#x2F;magnifier.svg&quot;&gt;&lt;div class=&quot;magnifier-info&quot;&gt;×1&lt;br&gt;png&lt;&#x2F;div&gt;
&lt;&#x2F;div&gt;
&lt;&#x2F;div&gt;
&lt;p&gt;Затем уберём все связи, и расположим все нейроны сверху-вниз, и сделаем второй столбик-дубликат первого. Это показано на следующей картинке слева. &lt;&#x2F;p&gt;
&lt;p&gt;Теперь просто остаётся добавить связи, но добавлять будем таким образом, что связь может быть направлена только из левого столбика в правый. Результат показан на правой части картинки.&lt;&#x2F;p&gt;
&lt;div class=&quot;magnifier-container img-one&quot;&gt;
&lt;img
    class=&quot;not-default full-screen-img&quot;
    width=&quot;428&quot;
    height=&quot;806&quot;
    src=&quot;&amp;#x2F;processed_images&amp;#x2F;d1aa4d3e234ebbde00.webp&quot; 
    onclick=&quot;full_screen(&#x27;arbitrary_nn_two.png&#x27;)&quot;
    onauxclick=&quot;full_screen_new_page(&#x27;arbitrary_nn_two.png&#x27;)&quot;&gt;
&lt;div class=&quot;magnifier-display&quot;&gt;
&lt;img class=&quot;magnifier&quot; src=&quot;&#x2F;ico&#x2F;magnifier.svg&quot;&gt;&lt;div class=&quot;magnifier-info&quot;&gt;×1&lt;br&gt;png&lt;&#x2F;div&gt;
&lt;&#x2F;div&gt;
&lt;&#x2F;div&gt;
&lt;p&gt;Это и есть реккурентная нейросеть, мы свели всё к ней! Значит, реккурентная нейросеть способна представить любую топологию нейросети, и нет смысла изобретать свои собственные велосипеды.&lt;&#x2F;p&gt;
&lt;p&gt;Как видно, здесь слева не используются выходные нейроны, а справа не используются входные нейроны.&lt;&#x2F;p&gt;
&lt;p&gt;И действительно, если подумать как здесь протекают сигналы, это просто другой способ обозначения нейросети с произвольной архитектурой. Это даже напоминает матрицу смежности для представления графа. То есть можно визуализировать это так:&lt;&#x2F;p&gt;
&lt;div class=&quot;magnifier-container img-one&quot;&gt;
&lt;img
    class=&quot;not-default full-screen-img&quot;
    width=&quot;808&quot;
    height=&quot;798&quot;
    src=&quot;&amp;#x2F;processed_images&amp;#x2F;1b74f95829bf076c00.webp&quot; 
    onclick=&quot;full_screen(&#x27;matrix_nn.png&#x27;)&quot;
    onauxclick=&quot;full_screen_new_page(&#x27;matrix_nn.png&#x27;)&quot;&gt;
&lt;div class=&quot;magnifier-display&quot;&gt;
&lt;img class=&quot;magnifier&quot; src=&quot;&#x2F;ico&#x2F;magnifier.svg&quot;&gt;&lt;div class=&quot;magnifier-info&quot;&gt;×1&lt;br&gt;png&lt;&#x2F;div&gt;
&lt;&#x2F;div&gt;
&lt;&#x2F;div&gt;
&lt;p&gt;Так как веса не заданы, то можно просто обозначить наличие связи при помощи красного квадрата. И в таком виде очевидно, что входные и выходные данные надо представлять как вектор, а саму нейросеть как матрицу.&lt;&#x2F;p&gt;
&lt;p&gt;Кстати в таком виде невозможно обозначить больше чем одну связь из одной ноды в другую. Вообще не знаю зачем это может понадобиться, кроме как использовать разные функции активации, да и это тоже вполне бессмысленная вещь, так что оставим этот случай.&lt;&#x2F;p&gt;
&lt;div class=&quot;magnifier-container img-one&quot;&gt;
&lt;img
    class=&quot;not-default full-screen-img&quot;
    width=&quot;241&quot;
    height=&quot;81&quot;
    src=&quot;&amp;#x2F;processed_images&amp;#x2F;968306985082cb6500.webp&quot; 
    onclick=&quot;full_screen(&#x27;not_allowed.png&#x27;)&quot;
    onauxclick=&quot;full_screen_new_page(&#x27;not_allowed.png&#x27;)&quot;&gt;
&lt;div class=&quot;magnifier-display&quot;&gt;
&lt;img class=&quot;magnifier&quot; src=&quot;&#x2F;ico&#x2F;magnifier.svg&quot;&gt;&lt;div class=&quot;magnifier-info&quot;&gt;×1&lt;br&gt;png&lt;&#x2F;div&gt;
&lt;&#x2F;div&gt;
&lt;&#x2F;div&gt;
&lt;h1 id=&quot;pochemu-eto-luchshe&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#pochemu-eto-luchshe&quot;&gt;#&lt;&#x2F;a&gt;Почему это лучше&lt;&#x2F;h1&gt;
&lt;p&gt;И я даже скажу, что в таком виде произвольная нейросеть получается лучше, чем её изначальный интуитивный вид. Почему?&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Во-первых&lt;&#x2F;strong&gt; вы можете использовать всю мощь, что развилась вокруг реккурентных нейросетей, будь то софт для их обучения или множество научных работ, например про преодоление взрыва градиентов.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Во-вторых&lt;&#x2F;strong&gt; представлять её таким образом в памяти вычислительно эффективней. Предположим как бы вы стали реализовывать класс, обрабатывающий нейросеть, которую мы нарисовали в самом начале? Наверняка бы делали напрямик: хранили бы где-то массив импульсов, хранили бы граф связей и перемещали бы импульсы по этому графу. А распараллеливать это добро очень сложно.&lt;&#x2F;p&gt;
&lt;p&gt;А реккурентные нейросети очень легко представляются матрицей, которую можно просто умножать на вектор чисел. Это даже с точки зрения кэша процессора куда эффективнее. Тем более для умножения матриц уже написали вагон и маленькую тележку сверх-быстрых параллельных библиотек, не говоря о умножении матриц на видеокарте.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;kak-ia-prishiol-k-etoi-idee&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#kak-ia-prishiol-k-etoi-idee&quot;&gt;#&lt;&#x2F;a&gt;Как я пришёл к этой идее&lt;&#x2F;h1&gt;
&lt;p&gt;Совершенно случайно. Нигде об этом прямым текстом не пишется. Мне непонятно, почему, ведь это очень важно! Можно же было просто написать:&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;Реккурентная нейронная сеть позволяет имитировать нейросеть, представляющую из себя произвольный граф.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h1 id=&quot;zakliuchenie&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#zakliuchenie&quot;&gt;#&lt;&#x2F;a&gt;Заключение&lt;&#x2F;h1&gt;
&lt;p&gt;Так что не взорвём мы науку с нашими произвольными нейросетями, они уже существовали до нас, но скрывались под другим названием, просто никто толком не знал, что это они.&lt;&#x2F;p&gt;
&lt;p&gt;А теперь в следующий раз, когда надумаете писать свою эволюцию агентов с произвольными нейросетями и аниме-тянками, вы не наступите на грабли велосипедостроения, и сможете использовать отлаженный и оптимизированный инструментарий реккурентных нейросетей!&lt;&#x2F;p&gt;
&lt;p&gt;Кстати, приглашаю всех людей, заинтересованных в симуляции эволюции, в чатик в телеграме: &lt;a href=&quot;https:&#x2F;&#x2F;t.me&#x2F;emergevolution&quot;&gt;https:&#x2F;&#x2F;t.me&#x2F;emergevolution&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>Обозначения для линейной алгебры</title>
            <pubDate>Sat, 09 Nov 2019 00:00:00 +0000</pubDate>
            <link>https://testzorax.github.io/p/linear-algebra/</link>
            <guid>https://testzorax.github.io/p/linear-algebra/</guid>
            <description>&lt;h1 id=&quot;vvedenie&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#vvedenie&quot;&gt;#&lt;&#x2F;a&gt;Введение&lt;&#x2F;h1&gt;
&lt;p&gt;Знаете же эту байку, что после внедрения арабских цифр вместо римских, развитие математики пошло семимильными шагами?&lt;&#x2F;p&gt;
&lt;p&gt;Из этой байки можно сделать вывод, что иногда хорошая система обозначений или кодировки чего-то, может оказывать значительное влияние на то, как люди это воспринимают и насколько легко могут этим оперировать.&lt;&#x2F;p&gt;
&lt;p&gt;В данной статье рассказывается об обозначениях для базисов, векторов и линейных операторов, при помощи которых можно намного лучше понимать что же, чёрт возьми, происходит в линейной алгебре.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;abstraktnyi-vektor&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#abstraktnyi-vektor&quot;&gt;#&lt;&#x2F;a&gt;Абстрактный вектор&lt;&#x2F;h1&gt;
&lt;script type=&quot;math&#x2F;tex&quot;&gt;&lt;&#x2F;script&gt;
&lt;p&gt;Со школы мы привыкли, что вектор - это набор &lt;strong&gt;чисел&lt;&#x2F;strong&gt; &lt;script type=&quot;math&#x2F;tex&quot;&gt;\mathbf{x} = (1, 2, 3)^T&lt;&#x2F;script&gt;. Но в линейной алгебре любой вектор - это &lt;em&gt;абстрактный объект&lt;&#x2F;em&gt;, обладающий определёнными свойствами. &lt;&#x2F;p&gt;
&lt;p&gt;Например у нас может быть два вектора: &lt;script type=&quot;math&#x2F;tex&quot;&gt;\mathbf{x} =&lt;&#x2F;script&gt;апельсиновый сок, &lt;script type=&quot;math&#x2F;tex&quot;&gt;\mathbf{y}=&lt;&#x2F;script&gt; яблочный сок. И тогда результатом их суммы может быть: &lt;script type=&quot;math&#x2F;tex&quot;&gt;\mathbf{x}+2\mathbf{y}=&lt;&#x2F;script&gt;однояблочно-двуапельсиновый сок.&lt;&#x2F;p&gt;
&lt;p&gt;Свойства вектора задаются определением &lt;a href=&quot;https:&#x2F;&#x2F;ru.wikipedia.org&#x2F;wiki&#x2F;%D0%92%D0%B5%D0%BA%D1%82%D0%BE%D1%80%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D1%81%D1%82%D1%80%D0%B0%D0%BD%D1%81%D1%82%D0%B2%D0%BE&quot;&gt;линейного пространства&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;oboznacheniia&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#oboznacheniia&quot;&gt;#&lt;&#x2F;a&gt;Обозначения&lt;&#x2F;h1&gt;
&lt;p&gt;При помощи долларов будет обозначаться, как это пишется в &lt;code&gt;TeX&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Число&lt;&#x2F;strong&gt; - маленькая буква, обычный шрифт, &lt;code&gt;$x$&lt;&#x2F;code&gt;, &lt;code&gt;$y$&lt;&#x2F;code&gt;, &lt;code&gt;$z$&lt;&#x2F;code&gt;: &lt;script type=&quot;math&#x2F;tex&quot;&gt;x&lt;&#x2F;script&gt;, &lt;script type=&quot;math&#x2F;tex&quot;&gt;y&lt;&#x2F;script&gt;, &lt;script type=&quot;math&#x2F;tex&quot;&gt;z&lt;&#x2F;script&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Абстрактный вектор&lt;&#x2F;strong&gt; - маленькая буква, жирным прямым шрифтом, &lt;code&gt;$\mathbf{x}$&lt;&#x2F;code&gt;: &lt;script type=&quot;math&#x2F;tex&quot;&gt;\mathbf{x}&lt;&#x2F;script&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Базис&lt;&#x2F;strong&gt; - маленькая буква, ажурным шрифтом, &lt;code&gt;$\mathbb{e}$&lt;&#x2F;code&gt;: 𝕖. Является вектор-строкой из абстрактных векторов:&lt;&#x2F;p&gt;
&lt;script type=&quot;math&#x2F;tex;mode=display&quot;&gt;𝕖=(\mathbf{e}_1, \mathbf{e}_2, \dots, \mathbf{e}_n)&lt;&#x2F;script&gt;
&lt;p&gt;&lt;strong&gt;Линейный оператор&lt;&#x2F;strong&gt; - большая буква, жирным шрифтом, &lt;code&gt;$\mathbf{A}$&lt;&#x2F;code&gt;: &lt;script type=&quot;math&#x2F;tex&quot;&gt;\mathbf{A}(\mathbf{x})&lt;&#x2F;script&gt;, обязательно использование скобок после него.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Численный вектор&lt;&#x2F;strong&gt; - абстрактный вектор, заключённый в квадратные скобки, и с дописанным снизу базисом, куда он спроецирован, &lt;code&gt;$[\mathbf{x}]_\mathbb{e}$&lt;&#x2F;code&gt;: &lt;script type=&quot;math&#x2F;tex&quot;&gt;[\mathbf{x}]_𝕖&lt;&#x2F;script&gt;. Это вектор &lt;script type=&quot;math&#x2F;tex&quot;&gt;\mathbf{x}&lt;&#x2F;script&gt; в базисе &lt;script type=&quot;math&#x2F;tex&quot;&gt;𝕖&lt;&#x2F;script&gt;. Является вектор-столбцом чисел.&lt;&#x2F;p&gt;
&lt;script type=&quot;math&#x2F;tex;mode=display&quot;&gt;[\mathbf{x}]_𝕖 = 
\begin{pmatrix}
	x_1\\
	x_2\\
	\ldots\\
	x_n
\end{pmatrix}&lt;&#x2F;script&gt;
&lt;p&gt;Любой абстрактный вектор можно представить в виде:&lt;&#x2F;p&gt;
&lt;script type=&quot;math&#x2F;tex;mode=display&quot;&gt;\mathbf{x} = 𝕖\cdot [\mathbf{x}]_𝕖&lt;&#x2F;script&gt;
&lt;script type=&quot;math&#x2F;tex;mode=display&quot;&gt;\mathbf{x} = (\mathbf{e}_1, \mathbf{e}_2, \dots, \mathbf{e}_n)\cdot\begin{pmatrix}
	x_1\\
	x_2\\
	\ldots\\
	x_n
\end{pmatrix}&lt;&#x2F;script&gt;
&lt;script type=&quot;math&#x2F;tex;mode=display&quot;&gt;\mathbf{x} = x_1\mathbf{e}_1 + x_2\mathbf{e}_2 + \dots + x_n\mathbf{e}_n&lt;&#x2F;script&gt;
&lt;p&gt;Эти формулы задают соответствие между абстрактным и численными векторами!&lt;&#x2F;p&gt;
&lt;p&gt;Заметьте, что можно ввести базис &lt;script type=&quot;math&#x2F;tex&quot;&gt;𝕒=(\mathbf{a}_1, \mathbf{a}_2, \dots, \mathbf{a}_n)&lt;&#x2F;script&gt;. Тогда можно записать вектор &lt;script type=&quot;math&#x2F;tex&quot;&gt;\mathbf{x}&lt;&#x2F;script&gt; через этот базис:&lt;&#x2F;p&gt;
&lt;script type=&quot;math&#x2F;tex;mode=display&quot;&gt;\mathbf{x} = 𝕒\cdot [\mathbf{x}]_𝕒&lt;&#x2F;script&gt;
&lt;p&gt;И в другом базисе будут другие числа, но вектор останется одним и тем же. Конечно, на практике мы никогда не столкнёмся с абстрактными векторами, а всегда будем работать с числовыми столбцами, но это удобная абстракция, чтобы обозначить один и тот же объект.&lt;&#x2F;p&gt;
&lt;p&gt;По сути численный вектор - это &lt;em&gt;проекция&lt;&#x2F;em&gt; абстрактного вектора на базис.&lt;&#x2F;p&gt;
&lt;p&gt;Кстати, линейные операции над вектором равносильны линейным операциям над его координатным столбцом:&lt;&#x2F;p&gt;
&lt;script type=&quot;math&#x2F;tex;mode=display&quot;&gt;[c\cdot \mathbf{x}]_𝕖 = c\cdot [\mathbf{x}]_𝕖 &lt;&#x2F;script&gt;
&lt;script type=&quot;math&#x2F;tex;mode=display&quot;&gt;\displaystyle [\mathbf{x} + \mathbf{y}]_𝕖 = [\mathbf{x}]_𝕖 + [\mathbf{y}]_𝕖 &lt;&#x2F;script&gt;
&lt;h1 id=&quot;perekhod-iz-odnogo-bazisa-v-drugoi&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#perekhod-iz-odnogo-bazisa-v-drugoi&quot;&gt;#&lt;&#x2F;a&gt;Переход из одного базиса в другой&lt;&#x2F;h1&gt;
&lt;p&gt;В этой задаче данные обозначения проявляют свою силу, потому что со стандартными обозначениями в ней происходит больше всего путаницы при решении задач.&lt;&#x2F;p&gt;
&lt;p&gt;Скажем, мы смогли выразить вектора базиса &lt;script type=&quot;math&#x2F;tex&quot;&gt;𝕒&lt;&#x2F;script&gt; через вектора базиса &lt;script type=&quot;math&#x2F;tex&quot;&gt;𝕖&lt;&#x2F;script&gt;:&lt;&#x2F;p&gt;
&lt;script type=&quot;math&#x2F;tex;mode=display&quot;&gt;
\left\{
\begin{aligned}
	&amp;\mathbf{a_1} = 𝕖 \cdot [a_1]_𝕖 = \alpha_{1,1}\mathbf{e_1} + \alpha_{1,2}\mathbf{e_2} + \ldots + \alpha_{1,n}\mathbf{e_n} \\
	&amp;\mathbf{a_2} = 𝕖 \cdot [a_2]_𝕖 = \alpha_{2,1}\mathbf{e_1} + \alpha_{2,2}\mathbf{e_2} + \ldots + \alpha_{2,n}\mathbf{e_n} \\
	&amp;\ldots \\
	&amp;\mathbf{a_n} = 𝕖 \cdot [a_n]_𝕖 = \alpha_{n,1}\mathbf{e_1} + \alpha_{n,2}\mathbf{e_2} + \ldots + \alpha_{n,n}\mathbf{e_n}
\end{aligned}
\right.
&lt;&#x2F;script&gt;
&lt;p&gt;И ввёдем такую матрицу:&lt;&#x2F;p&gt;
&lt;script type=&quot;math&#x2F;tex;mode=display&quot;&gt;
P_{𝕖𝕒} = 
\left([a_1]_𝕖, [a_2]_𝕖, \ldots, [a_n]_𝕖\right)
&lt;&#x2F;script&gt;
&lt;script type=&quot;math&#x2F;tex;mode=display&quot;&gt;
P_{𝕖𝕒} = 
\begin{pmatrix}
	\alpha_{1,1}&amp; \alpha_{2, 1}&amp; \ldots&amp; \alpha_{n,1} \\
	\alpha_{1,2}&amp; \alpha_{2, 2}&amp; \ldots&amp; \alpha_{n,2} \\
	\ldots&amp; \ldots&amp; \ldots&amp; \ldots \\
	\alpha_{1,n}&amp; \alpha_{2, n}&amp; \ldots&amp; \alpha_{n,n}
\end{pmatrix}
&lt;&#x2F;script&gt;
&lt;p&gt;Тогда изначальная система равносильна следующим записям:&lt;&#x2F;p&gt;
&lt;script type=&quot;math&#x2F;tex;mode=display&quot;&gt;
\begin{matrix}
	&amp;P_{𝕖𝕒}^T \cdot 𝕖^T &amp;= &amp;𝕒^T \\
	&amp;𝕖 \cdot P_{𝕖𝕒} &amp;= &amp;𝕒 \\
	&amp;𝕒 \cdot P_{𝕖𝕒}^{-1} &amp;= &amp;𝕖 \\
	&amp;𝕒 \cdot P_{𝕒𝕖} &amp;= &amp;𝕖
\end{matrix}
&lt;&#x2F;script&gt;
&lt;script type=&quot;math&#x2F;tex&quot;&gt;P_{𝕖𝕒}&lt;&#x2F;script&gt; называется матрицей перехода от базиса 𝕖 к базису 𝕒.
&lt;p&gt;Из имеющихся у нас формул можно вывести ещё несколько полезных:&lt;&#x2F;p&gt;
&lt;script type=&quot;math&#x2F;tex;mode=display&quot;&gt; P_{𝕖𝕒} = P_{𝕒𝕖}^{-1} &lt;&#x2F;script&gt;
&lt;script type=&quot;math&#x2F;tex;mode=display&quot;&gt; 𝕒 = 𝕖 \cdot P_{𝕖𝕒} &lt;&#x2F;script&gt;
&lt;script type=&quot;math&#x2F;tex;mode=display&quot;&gt; P_{𝕒𝕕} = P_{𝕒𝕖}\cdot P_{𝕖𝕕} &lt;&#x2F;script&gt;
&lt;script type=&quot;math&#x2F;tex;mode=display&quot;&gt; [\mathbf{x}]_𝕒 = P_{𝕖𝕒} \cdot [\mathbf{x}]_𝕖 &lt;&#x2F;script&gt;
&lt;p&gt;Благодаря полученным формулам мы теперь знаем как переводить численные вектора из одного базиса в другой.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;lineinyi-operator&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#lineinyi-operator&quot;&gt;#&lt;&#x2F;a&gt;Линейный оператор&lt;&#x2F;h1&gt;
&lt;p&gt;&lt;strong&gt;Линейный оператор&lt;&#x2F;strong&gt; - это функция, принимающая на вход вектор, и возвращающая вектор. При этом пространство первого вектора может отличаться от пространства второго вектора. &lt;&#x2F;p&gt;
&lt;p&gt;В математике любят писать: &lt;script type=&quot;math&#x2F;tex&quot;&gt;\mathbf{A}\mathbf{x}&lt;&#x2F;script&gt;, что означает, что &amp;quot;оператор применяется к вектору&amp;quot;. Меня эта нотация бесит. Она похожа на умножение, и всегда надо заранее знать, что &lt;script type=&quot;math&#x2F;tex&quot;&gt;\mathbf{A}&lt;&#x2F;script&gt; - функция.&lt;&#x2F;p&gt;
&lt;p&gt;Этот &amp;quot;оператор&amp;quot; называется &lt;em&gt;линейным&lt;&#x2F;em&gt;, потому что он обладает линейными свойствами (как и практически всё в линейной алгебре).&lt;&#x2F;p&gt;
&lt;script type=&quot;math&#x2F;tex;mode=display&quot;&gt;\mathbf{A}(\mathbf{x} + \mathbf{y}) = \mathbf{A}(\mathbf{x}) + \mathbf{A}(\mathbf{y})&lt;&#x2F;script&gt;
&lt;script type=&quot;math&#x2F;tex;mode=display&quot;&gt;\mathbf{A}(c\cdot\mathbf{x}) = c\cdot\mathbf{A}(\mathbf{x})&lt;&#x2F;script&gt;
&lt;p&gt;Чем же является линейный оператор в нашем мире чисел? Оказывается, можно доказать, что любой линейный оператор для данных базисов можно свести к единственной матрице! При этом операция &amp;quot;применения оператора к вектору&amp;quot; будет являться умножением матрицы на этот вектор. &lt;&#x2F;p&gt;
&lt;script type=&quot;math&#x2F;tex;mode=display&quot;&gt;
[\mathbf{A}]_{𝕖𝕒}\cdot[\mathbf{x}]_𝕖 = [\mathbf{y}]_𝕒
&lt;&#x2F;script&gt;
&lt;p&gt;Именно из-за этого я стараюсь не использовать применения оператора без скобочек, потому что у нас появляется ещё больше шансов спутать абстрактный оператор с матрицей.&lt;&#x2F;p&gt;
&lt;p&gt;Заметьте, что матрица зависит от двух базисов: от входных данных и от результатов! Ведь результат может быть 50-мерный вектор, а вход - 2-мерный. Конечно, на практике чаще встречается, что вход и выход находятся в одном базисе и следовательно имеют одинаковую размерность. Поэтому покажу обозначение именно для этого случая:&lt;&#x2F;p&gt;
&lt;script type=&quot;math&#x2F;tex;mode=display&quot;&gt;
[\mathbf{A}]_𝕖\cdot[\mathbf{x}]_𝕖 = [\mathbf{y}]_𝕖
&lt;&#x2F;script&gt;
&lt;p&gt;Ещё раз подчеркну, линейный оператор ≠ матрице линейного оператора. &lt;&#x2F;p&gt;
&lt;p&gt;Линейный оператор - это абстрактная функция, а матрица - это конкретная её реализация в виде набора чисел.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;vyvod-formuly-perevoda-matritsy-lineinogo-operatora&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#vyvod-formuly-perevoda-matritsy-lineinogo-operatora&quot;&gt;#&lt;&#x2F;a&gt;Вывод формулы перевода матрицы линейного оператора&lt;&#x2F;h1&gt;
&lt;p&gt;Скажем, мы знаем как линейный оператор представляется в пространстве &lt;script type=&quot;math&#x2F;tex&quot;&gt;𝕖&lt;&#x2F;script&gt;:&lt;&#x2F;p&gt;
&lt;script type=&quot;math&#x2F;tex;mode=display&quot;&gt;[\mathbf{A}]_𝕖\cdot[\mathbf{x}]_𝕖 = [\mathbf{y}]_𝕖&lt;&#x2F;script&gt;
&lt;p&gt;И нам нужно получить его матрицу в базисе &lt;script type=&quot;math&#x2F;tex&quot;&gt;𝕒&lt;&#x2F;script&gt;, то есть такую матрицу, чтобы выполнялось следующее равенство:&lt;&#x2F;p&gt;
&lt;script type=&quot;math&#x2F;tex;mode=display&quot;&gt;[\mathbf{A}]_𝕒\cdot[\mathbf{x}]_𝕒 = [\mathbf{y}]_𝕒&lt;&#x2F;script&gt;
&lt;p&gt;Тогда для вывода нам понадобится следующее:&lt;&#x2F;p&gt;
&lt;script type=&quot;math&#x2F;tex;mode=display&quot;&gt; [\mathbf{x}]_𝕖 = P_{𝕒𝕖} \cdot [\mathbf{x}]_𝕒 &lt;&#x2F;script&gt;
&lt;script type=&quot;math&#x2F;tex;mode=display&quot;&gt;[\mathbf{y}]_𝕖 = P_{𝕒𝕖} \cdot [\mathbf{y}]_𝕒&lt;&#x2F;script&gt;
&lt;script type=&quot;math&#x2F;tex;mode=display&quot;&gt;[\mathbf{A}]_𝕖\cdot[\mathbf{x}]_𝕖 = [\mathbf{y}]_𝕖&lt;&#x2F;script&gt;
&lt;p&gt;Подставляем первые две формулы в третью:&lt;&#x2F;p&gt;
&lt;script type=&quot;math&#x2F;tex;mode=display&quot;&gt;[\mathbf{A}]_𝕖\cdot P_{𝕒𝕖} \cdot [\mathbf{x}]_𝕒 = P_{𝕒𝕖} \cdot [\mathbf{y}]_𝕒&lt;&#x2F;script&gt;
&lt;script type=&quot;math&#x2F;tex;mode=display&quot;&gt;P_{𝕒𝕖}^{-1} \cdot [\mathbf{A}]_𝕖\cdot P_{𝕒𝕖} \cdot [\mathbf{x}]_𝕒 = [\mathbf{y}]_𝕒&lt;&#x2F;script&gt;
&lt;p&gt;И получаем такой ответ:&lt;&#x2F;p&gt;
&lt;script type=&quot;math&#x2F;tex;mode=display&quot;&gt;[\mathbf{A}]_𝕒 = P_{𝕒𝕖}^{-1} \cdot [\mathbf{A}]_𝕒\cdot P_{𝕒𝕖}&lt;&#x2F;script&gt;
&lt;h1 id=&quot;pochemu-eti-oboznacheniia-khoroshi&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#pochemu-eti-oboznacheniia-khoroshi&quot;&gt;#&lt;&#x2F;a&gt;Почему эти обозначения хороши?&lt;&#x2F;h1&gt;
&lt;p&gt;Вы могли заметить, что впервые в жизни поняли что происходит в этой чертовой линейной алгебре, и это неспроста. В стандартных обозначениях нет никакого разделения между вектором, его проекцией на базис, и базисом. Всё &lt;strong&gt;тупо&lt;&#x2F;strong&gt; и &lt;strong&gt;лениво&lt;&#x2F;strong&gt; обозначается обычными нежирными неажурными буквами. &lt;&#x2F;p&gt;
&lt;p&gt;Именно из-за этого тебе постоянно приходится помнить о контексте. И ещё хорошо, если тебе расскажут разницу между абстрактным вектором и числовым столбцом. Обычно преподаватели сами толком не знают разницу, или не знают что на неё надо обратить внимание студентов.&lt;&#x2F;p&gt;
&lt;p&gt;Минус тупого обозначения всего обычными буквами в том, что &lt;strong&gt;обычные буквы начинают обозначать слишком много&lt;&#x2F;strong&gt;. У них появляется многозначность. В зависимости от контекста &lt;script type=&quot;math&#x2F;tex&quot;&gt;a&lt;&#x2F;script&gt; мог быть чем угодно: числом, вектором, базисом и даже оператором младшим.&lt;&#x2F;p&gt;
&lt;p&gt;Соглашусь, что эта система обозначения координатных столцом слишком многосимвольна: для её написания требуется писать &lt;code&gt;[&lt;&#x2F;code&gt;, &lt;code&gt;]&lt;&#x2F;code&gt;, &lt;code&gt;𝕖&lt;&#x2F;code&gt;, а как писать последнее при помощи ручки вообще непонятно. Применять её на практике для решения задач в линейной алгебре невозможно. Поэтому я предлагаю использовать такие обозначения для:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Книг и методичек,&lt;&#x2F;li&gt;
&lt;li&gt;На бумаге, когда в задании фигурирует переход из одного базиса в другой,&lt;&#x2F;li&gt;
&lt;li&gt;На начальных этапах, чтобы различать абстрактный вектор и столбец чисел,&lt;&#x2F;li&gt;
&lt;li&gt;Когда забыл как всё работает.
Далее же, &lt;em&gt;когда научишься всё понимать&lt;&#x2F;em&gt;, можно использовать обычные буквы, для сокращения записей.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Данная система является немного доработанной системой обозначений, рассказанной &lt;a href=&quot;https:&#x2F;&#x2F;ciu.nstu.ru&#x2F;kaf&#x2F;persons&#x2F;3080&quot;&gt;Овчинниковой Еленой Викторовной&lt;&#x2F;a&gt; на факультете АВТ, университета НГТУ.&lt;&#x2F;p&gt;
&lt;p&gt;Главными фичами этой системы обозначений является:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Вектор разделён на два понятия: абстрактный и числовой.&lt;&#x2F;li&gt;
&lt;li&gt;Для каждого из классов придуманы особые обозначения.&lt;&#x2F;li&gt;
&lt;li&gt;Базис у числого вектора не игнорируется и находится в его обозначении.&lt;&#x2F;li&gt;
&lt;li&gt;Для базиса выбран особый шрифт, чтобы его нельзя было спутать с вектором или числом.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h1 id=&quot;vyvod&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#vyvod&quot;&gt;#&lt;&#x2F;a&gt;Вывод&lt;&#x2F;h1&gt;
&lt;center&gt;&lt;big&gt;Правильные обозначения важны.&lt;&#x2F;big&gt;&lt;&#x2F;center&gt;</description>
        </item>
    </channel>
</rss>
