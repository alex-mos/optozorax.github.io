<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
      <title>optozorax.blog - математика</title>
        <link>https://testzorax.github.io/</link>
        <description>Мои програмульки и результаты их работы</description>
        <generator>Zola</generator>
        <language>ru</language>
        <atom:link href="https://testzorax.github.io/tags/matematika/rss.xml" rel="self" type="application/rss+xml"/>
        <lastBuildDate>Wed, 28 Jul 2021 00:00:00 +0000</lastBuildDate>
        <item>
            <title>Свойства обратимых 1D автоматов</title>
            <pubDate>Wed, 28 Jul 2021 00:00:00 +0000</pubDate>
            <link>https://testzorax.github.io/p/invertible-1d-automata/</link>
            <guid>https://testzorax.github.io/p/invertible-1d-automata/</guid>
            <description>&lt;style&gt;
.container { 
  display: flex; 
  flex-direction: row;
  flex-wrap: wrap;
  justify-content: space-around;
  width: 90%;
  border: 1px solid gray;
  padding: 10px;
  margin: 5px;
}
.automata-col {
  border: 1px solid rgba(39,41,43,0.1); 
  background-color: rgba(39,41,43,0.03);
  padding: 10px;
  margin: 5px;
  min-width: 110px;
  flex: 1 0 0%;
}
.pixelated {
  -ms-interpolation-mode: nearest-neighbor;
  image-rendering: crisp-edges;
  image-rendering: pixelated;
}

.skip-img {
  display: none;
}

.skip-img, .both-img, .any-img {
  width: 150px;
  margin: 2px;
  border-radius: 0px;
}
.automata-name {
  font-size: 12pt;
  font-family: monospace;
}
.svg {
}
&lt;&#x2F;style&gt;
&lt;h1 id=&quot;vvedenie&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#vvedenie&quot;&gt;#&lt;&#x2F;a&gt;Введение&lt;&#x2F;h1&gt;
&lt;p&gt;Предполагается что перед чтением этой статьи вы уже знакомы с тем что такое Клеточный автомат, и знакомы с правилом &lt;code&gt;110&lt;&#x2F;code&gt; или правилом &lt;code&gt;30&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Если нет, то рекомендуется прочитать эти две статьи:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;habr.com&#x2F;ru&#x2F;post&#x2F;273393&#x2F;&quot;&gt;Простейшие клеточные автоматы и их практическое применение&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;habr.com&#x2F;ru&#x2F;company&#x2F;wolfram&#x2F;blog&#x2F;470425&#x2F;&quot;&gt;30.000$ за решение задач о Правиле 30 для клеточных автоматов — конкурс от Стивена Вольфрама&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Ещё предполагается что вы знакомы с тем что такое &lt;strong&gt;обратимый&lt;&#x2F;strong&gt; клеточный автомат. Если нет, то рекомендуется прочитать эту статью на Википедии:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;ru.wikipedia.org&#x2F;wiki&#x2F;%D0%9A%D1%80%D0%B8%D1%82%D1%82%D0%B5%D1%80%D1%8B&quot;&gt;Криттеры&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Так же я писал про обратимые автоматы в своём телеграм канале начиная отсюда: &lt;a href=&quot;https:&#x2F;&#x2F;t.me&#x2F;optozorax_dev&#x2F;235&quot;&gt;optozorax_dev&#x2F;235&lt;&#x2F;a&gt; на 7 постов.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;tablitsa-avtomatov&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#tablitsa-avtomatov&quot;&gt;#&lt;&#x2F;a&gt;Таблица автоматов&lt;&#x2F;h1&gt;
&lt;p&gt;В данной статье я хочу аналогично предыдущим рассмотреть одномерные обратимые клеточные автоматы и выяснить их свойства.&lt;&#x2F;p&gt;
&lt;p&gt;Обратимые клеточные автоматы можно получить множеством способов, но я выберу именно тот, которым сконструированы Криттеры, а именно — соседство Марголуса. В одномерном случае оно будет иметь размер 2 бита, поэтому количество возможных состояний будет равно 2² = 4, а количество возможных правил равно 2²! = 24.&lt;&#x2F;p&gt;
&lt;p&gt;Все эти автоматы можно посмотреть в таблице ниже. Здесь всё начинается со случайной строки из нулей и единиц, конец которой замкнут на начало. Затем к ней применяются правила данного автомата, и каждая получающаяся строка прибавляется вниз картинки. То есть на картинках время идёт вниз, а направление вправо или влево. Сверху подписан номер автомата (число от 0 до 23), а снизу подписано правило этого автомата, то есть перестановка чисел &lt;code&gt;[0, 1, 2, 3]&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;center&gt;
&lt;div class=&quot;container&quot;&gt;
&lt;div class=&quot;automata-col trivial trivial_two time_symmetricale anti_time_symmetricale self_mirror self_inverse save_count&quot;&gt;
&lt;span class=&quot;automata-name&quot;&gt;&lt;b&gt;0&lt;&#x2F;b&gt;&lt;&#x2F;span&gt;&lt;br&gt;
&lt;img class=&quot;pixelated skip-img&quot; src=&quot;img&#x2F;0_skip.png&quot;&gt;
&lt;img class=&quot;pixelated both-img&quot; src=&quot;img&#x2F;0_both.png&quot;&gt;
&lt;span class=&quot;automata-name&quot;&gt;[0 1 2 3]&lt;&#x2F;span&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;automata-col time_symmetricale&quot;&gt;
&lt;span class=&quot;automata-name&quot;&gt;&lt;b&gt;1&lt;&#x2F;b&gt;&lt;&#x2F;span&gt;&lt;br&gt;
&lt;img class=&quot;pixelated skip-img&quot; src=&quot;img&#x2F;1_skip.png&quot;&gt;
&lt;img class=&quot;pixelated both-img&quot; src=&quot;img&#x2F;1_both.png&quot;&gt;
&lt;span class=&quot;automata-name&quot;&gt;[0 1 3 2]&lt;&#x2F;span&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;automata-col time_symmetricale anti_time_symmetricale self_mirror self_inverse save_count&quot;&gt;
&lt;span class=&quot;automata-name&quot;&gt;&lt;b&gt;2&lt;&#x2F;b&gt;&lt;&#x2F;span&gt;&lt;br&gt;
&lt;img class=&quot;pixelated skip-img&quot; src=&quot;img&#x2F;2_skip.png&quot;&gt;
&lt;img class=&quot;pixelated both-img&quot; src=&quot;img&#x2F;2_both.png&quot;&gt;
&lt;span class=&quot;automata-name&quot;&gt;[0 2 1 3]&lt;&#x2F;span&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;automata-col&quot;&gt;
&lt;span class=&quot;automata-name&quot;&gt;&lt;b&gt;3&lt;&#x2F;b&gt;&lt;&#x2F;span&gt;&lt;br&gt;
&lt;img class=&quot;pixelated skip-img&quot; src=&quot;img&#x2F;3_skip.png&quot;&gt;
&lt;img class=&quot;pixelated both-img&quot; src=&quot;img&#x2F;3_both.png&quot;&gt;
&lt;span class=&quot;automata-name&quot;&gt;[0 2 3 1]&lt;&#x2F;span&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;automata-col&quot;&gt;
&lt;span class=&quot;automata-name&quot;&gt;&lt;b&gt;4&lt;&#x2F;b&gt;&lt;&#x2F;span&gt;&lt;br&gt;
&lt;img class=&quot;pixelated skip-img&quot; src=&quot;img&#x2F;4_skip.png&quot;&gt;
&lt;img class=&quot;pixelated both-img&quot; src=&quot;img&#x2F;4_both.png&quot;&gt;
&lt;span class=&quot;automata-name&quot;&gt;[0 3 1 2]&lt;&#x2F;span&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;automata-col time_symmetricale&quot;&gt;
&lt;span class=&quot;automata-name&quot;&gt;&lt;b&gt;5&lt;&#x2F;b&gt;&lt;&#x2F;span&gt;&lt;br&gt;
&lt;img class=&quot;pixelated skip-img&quot; src=&quot;img&#x2F;5_skip.png&quot;&gt;
&lt;img class=&quot;pixelated both-img&quot; src=&quot;img&#x2F;5_both.png&quot;&gt;
&lt;span class=&quot;automata-name&quot;&gt;[0 3 2 1]&lt;&#x2F;span&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;automata-col time_symmetricale&quot;&gt;
&lt;span class=&quot;automata-name&quot;&gt;&lt;b&gt;6&lt;&#x2F;b&gt;&lt;&#x2F;span&gt;&lt;br&gt;
&lt;img class=&quot;pixelated skip-img&quot; src=&quot;img&#x2F;6_skip.png&quot;&gt;
&lt;img class=&quot;pixelated both-img&quot; src=&quot;img&#x2F;6_both.png&quot;&gt;
&lt;span class=&quot;automata-name&quot;&gt;[1 0 2 3]&lt;&#x2F;span&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;automata-col trivial_two time_symmetricale anti_time_symmetricale self_inverse&quot;&gt;
&lt;span class=&quot;automata-name&quot;&gt;&lt;b&gt;7&lt;&#x2F;b&gt;&lt;&#x2F;span&gt;&lt;br&gt;
&lt;img class=&quot;pixelated skip-img&quot; src=&quot;img&#x2F;7_skip.png&quot;&gt;
&lt;img class=&quot;pixelated both-img&quot; src=&quot;img&#x2F;7_both.png&quot;&gt;
&lt;span class=&quot;automata-name&quot;&gt;[1 0 3 2]&lt;&#x2F;span&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;automata-col&quot;&gt;
&lt;span class=&quot;automata-name&quot;&gt;&lt;b&gt;8&lt;&#x2F;b&gt;&lt;&#x2F;span&gt;&lt;br&gt;
&lt;img class=&quot;pixelated skip-img&quot; src=&quot;img&#x2F;8_skip.png&quot;&gt;
&lt;img class=&quot;pixelated both-img&quot; src=&quot;img&#x2F;8_both.png&quot;&gt;
&lt;span class=&quot;automata-name&quot;&gt;[1 2 0 3]&lt;&#x2F;span&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;automata-col anti_time_symmetricale&quot;&gt;
&lt;span class=&quot;automata-name&quot;&gt;&lt;b&gt;9&lt;&#x2F;b&gt;&lt;&#x2F;span&gt;&lt;br&gt;
&lt;img class=&quot;pixelated skip-img&quot; src=&quot;img&#x2F;9_skip.png&quot;&gt;
&lt;img class=&quot;pixelated both-img&quot; src=&quot;img&#x2F;9_both.png&quot;&gt;
&lt;span class=&quot;automata-name&quot;&gt;[1 2 3 0]&lt;&#x2F;span&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;automata-col self_inverse save_count&quot;&gt;
&lt;span class=&quot;automata-name&quot;&gt;&lt;b&gt;10&lt;&#x2F;b&gt;&lt;&#x2F;span&gt;&lt;br&gt;
&lt;img class=&quot;pixelated skip-img&quot; src=&quot;img&#x2F;10_skip.png&quot;&gt;
&lt;img class=&quot;pixelated both-img&quot; src=&quot;img&#x2F;10_both.png&quot;&gt;
&lt;span class=&quot;automata-name&quot;&gt;[1 3 0 2]&lt;&#x2F;span&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;automata-col&quot;&gt;
&lt;span class=&quot;automata-name&quot;&gt;&lt;b&gt;11&lt;&#x2F;b&gt;&lt;&#x2F;span&gt;&lt;br&gt;
&lt;img class=&quot;pixelated skip-img&quot; src=&quot;img&#x2F;11_skip.png&quot;&gt;
&lt;img class=&quot;pixelated both-img&quot; src=&quot;img&#x2F;11_both.png&quot;&gt;
&lt;span class=&quot;automata-name&quot;&gt;[1 3 2 0]&lt;&#x2F;span&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;automata-col&quot;&gt;
&lt;span class=&quot;automata-name&quot;&gt;&lt;b&gt;12&lt;&#x2F;b&gt;&lt;&#x2F;span&gt;&lt;br&gt;
&lt;img class=&quot;pixelated skip-img&quot; src=&quot;img&#x2F;12_skip.png&quot;&gt;
&lt;img class=&quot;pixelated both-img&quot; src=&quot;img&#x2F;12_both.png&quot;&gt;
&lt;span class=&quot;automata-name&quot;&gt;[2 0 1 3]&lt;&#x2F;span&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;automata-col self_inverse save_count&quot;&gt;
&lt;span class=&quot;automata-name&quot;&gt;&lt;b&gt;13&lt;&#x2F;b&gt;&lt;&#x2F;span&gt;&lt;br&gt;
&lt;img class=&quot;pixelated skip-img&quot; src=&quot;img&#x2F;13_skip.png&quot;&gt;
&lt;img class=&quot;pixelated both-img&quot; src=&quot;img&#x2F;13_both.png&quot;&gt;
&lt;span class=&quot;automata-name&quot;&gt;[2 0 3 1]&lt;&#x2F;span&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;automata-col time_symmetricale&quot;&gt;
&lt;span class=&quot;automata-name&quot;&gt;&lt;b&gt;14&lt;&#x2F;b&gt;&lt;&#x2F;span&gt;&lt;br&gt;
&lt;img class=&quot;pixelated skip-img&quot; src=&quot;img&#x2F;14_skip.png&quot;&gt;
&lt;img class=&quot;pixelated both-img&quot; src=&quot;img&#x2F;14_both.png&quot;&gt;
&lt;span class=&quot;automata-name&quot;&gt;[2 1 0 3]&lt;&#x2F;span&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;automata-col&quot;&gt;
&lt;span class=&quot;automata-name&quot;&gt;&lt;b&gt;15&lt;&#x2F;b&gt;&lt;&#x2F;span&gt;&lt;br&gt;
&lt;img class=&quot;pixelated skip-img&quot; src=&quot;img&#x2F;15_skip.png&quot;&gt;
&lt;img class=&quot;pixelated both-img&quot; src=&quot;img&#x2F;15_both.png&quot;&gt;
&lt;span class=&quot;automata-name&quot;&gt;[2 1 3 0]&lt;&#x2F;span&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;automata-col trivial_two time_symmetricale anti_time_symmetricale self_inverse&quot;&gt;
&lt;span class=&quot;automata-name&quot;&gt;&lt;b&gt;16&lt;&#x2F;b&gt;&lt;&#x2F;span&gt;&lt;br&gt;
&lt;img class=&quot;pixelated skip-img&quot; src=&quot;img&#x2F;16_skip.png&quot;&gt;
&lt;img class=&quot;pixelated both-img&quot; src=&quot;img&#x2F;16_both.png&quot;&gt;
&lt;span class=&quot;automata-name&quot;&gt;[2 3 0 1]&lt;&#x2F;span&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;automata-col anti_time_symmetricale&quot;&gt;
&lt;span class=&quot;automata-name&quot;&gt;&lt;b&gt;17&lt;&#x2F;b&gt;&lt;&#x2F;span&gt;&lt;br&gt;
&lt;img class=&quot;pixelated skip-img&quot; src=&quot;img&#x2F;17_skip.png&quot;&gt;
&lt;img class=&quot;pixelated both-img&quot; src=&quot;img&#x2F;17_both.png&quot;&gt;
&lt;span class=&quot;automata-name&quot;&gt;[2 3 1 0]&lt;&#x2F;span&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;automata-col anti_time_symmetricale&quot;&gt;
&lt;span class=&quot;automata-name&quot;&gt;&lt;b&gt;18&lt;&#x2F;b&gt;&lt;&#x2F;span&gt;&lt;br&gt;
&lt;img class=&quot;pixelated skip-img&quot; src=&quot;img&#x2F;18_skip.png&quot;&gt;
&lt;img class=&quot;pixelated both-img&quot; src=&quot;img&#x2F;18_both.png&quot;&gt;
&lt;span class=&quot;automata-name&quot;&gt;[3 0 1 2]&lt;&#x2F;span&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;automata-col&quot;&gt;
&lt;span class=&quot;automata-name&quot;&gt;&lt;b&gt;19&lt;&#x2F;b&gt;&lt;&#x2F;span&gt;&lt;br&gt;
&lt;img class=&quot;pixelated skip-img&quot; src=&quot;img&#x2F;19_skip.png&quot;&gt;
&lt;img class=&quot;pixelated both-img&quot; src=&quot;img&#x2F;19_both.png&quot;&gt;
&lt;span class=&quot;automata-name&quot;&gt;[3 0 2 1]&lt;&#x2F;span&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;automata-col&quot;&gt;
&lt;span class=&quot;automata-name&quot;&gt;&lt;b&gt;20&lt;&#x2F;b&gt;&lt;&#x2F;span&gt;&lt;br&gt;
&lt;img class=&quot;pixelated skip-img&quot; src=&quot;img&#x2F;20_skip.png&quot;&gt;
&lt;img class=&quot;pixelated both-img&quot; src=&quot;img&#x2F;20_both.png&quot;&gt;
&lt;span class=&quot;automata-name&quot;&gt;[3 1 0 2]&lt;&#x2F;span&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;automata-col time_symmetricale anti_time_symmetricale self_mirror self_inverse save_count&quot;&gt;
&lt;span class=&quot;automata-name&quot;&gt;&lt;b&gt;21&lt;&#x2F;b&gt;&lt;&#x2F;span&gt;&lt;br&gt;
&lt;img class=&quot;pixelated skip-img&quot; src=&quot;img&#x2F;21_skip.png&quot;&gt;
&lt;img class=&quot;pixelated both-img&quot; src=&quot;img&#x2F;21_both.png&quot;&gt;
&lt;span class=&quot;automata-name&quot;&gt;[3 1 2 0]&lt;&#x2F;span&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;automata-col anti_time_symmetricale&quot;&gt;
&lt;span class=&quot;automata-name&quot;&gt;&lt;b&gt;22&lt;&#x2F;b&gt;&lt;&#x2F;span&gt;&lt;br&gt;
&lt;img class=&quot;pixelated skip-img&quot; src=&quot;img&#x2F;22_skip.png&quot;&gt;
&lt;img class=&quot;pixelated both-img&quot; src=&quot;img&#x2F;22_both.png&quot;&gt;
&lt;span class=&quot;automata-name&quot;&gt;[3 2 0 1]&lt;&#x2F;span&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;automata-col trivial trivial_two time_symmetricale anti_time_symmetricale self_mirror self_inverse save_count&quot;&gt;
&lt;span class=&quot;automata-name&quot;&gt;&lt;b&gt;23&lt;&#x2F;b&gt;&lt;&#x2F;span&gt;&lt;br&gt;
&lt;img class=&quot;pixelated skip-img&quot; src=&quot;img&#x2F;23_skip.png&quot;&gt;
&lt;img class=&quot;pixelated both-img&quot; src=&quot;img&#x2F;23_both.png&quot;&gt;
&lt;span class=&quot;automata-name&quot;&gt;[3 2 1 0]&lt;&#x2F;span&gt;
&lt;&#x2F;div&gt;
&lt;&#x2F;div&gt;
&lt;&#x2F;center&gt;
&lt;p&gt;Так как соседство Марголуса требует на чётных шагах применять правила, начиная с чётных ячеек, а на нечётных шагах применять правила для нечётных ячеек, я добавил возможность включать и выключать показ нечётных шагов. Некоторые автоматы ведут себя одинаково для чётных шагов, например &lt;code&gt;0&lt;&#x2F;code&gt; ~ &lt;code&gt;23&lt;&#x2F;code&gt;, &lt;code&gt;2&lt;&#x2F;code&gt; ~ &lt;code&gt;10&lt;&#x2F;code&gt; ~ &lt;code&gt;13&lt;&#x2F;code&gt; ~ &lt;code&gt;21&lt;&#x2F;code&gt;. Это можно настраивать здесь:&lt;br&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;img_intermediate&quot; name=&quot;img_intermediate&quot; checked&gt; Показывать нечётные шаги&lt;&#x2F;label&gt;&lt;&#x2F;p&gt;
&lt;h1 id=&quot;razlichnye-svoistva&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#razlichnye-svoistva&quot;&gt;#&lt;&#x2F;a&gt;Различные свойства&lt;&#x2F;h1&gt;
&lt;p&gt;Ещё в данной таблице можно показать различные свойства автоматов. Можете выбирать конкретное свойство и пролистать вверх, автоматы обладающие им, подсветятся красным цветом.&lt;&#x2F;p&gt;
&lt;form name=&quot;properties_radio&quot;&gt;
&lt;label&gt;&lt;input type=&quot;radio&quot; name=&quot;prop&quot; value=&quot;all&quot; checked &gt; Убрать свойства&lt;&#x2F;label&gt;&lt;br&gt;
&lt;label&gt;&lt;input type=&quot;radio&quot; name=&quot;prop&quot; value=&quot;trivial&quot; &#x2F;&gt; Сохраняют текущее состояние&lt;&#x2F;label&gt;&lt;br&gt;
&lt;label&gt;&lt;input type=&quot;radio&quot; name=&quot;prop&quot; value=&quot;trivial_two&quot; &#x2F;&gt; Сохраняют через два состояния&lt;&#x2F;label&gt;&lt;br&gt;
&lt;label&gt;&lt;input type=&quot;radio&quot; name=&quot;prop&quot; value=&quot;self_mirror&quot; &#x2F;&gt; Зеркалирование правил приводит к самому себе&lt;&#x2F;label&gt;&lt;br&gt;
&lt;label&gt;&lt;input type=&quot;radio&quot; name=&quot;prop&quot; value=&quot;save_count&quot; &#x2F;&gt; Сохраняют количество закрашенных клеток&lt;&#x2F;label&gt;&lt;br&gt;
&lt;label&gt;&lt;input type=&quot;radio&quot; name=&quot;prop&quot; value=&quot;time_symmetricale&quot; &#x2F;&gt; Одинаковые законы для симуляции назад и вперёд во времени&lt;&#x2F;label&gt;&lt;br&gt;
&lt;label&gt;&lt;input type=&quot;radio&quot; name=&quot;prop&quot; value=&quot;anti_time_symmetricale&quot; &#x2F;&gt; Правило для симуляции назад во времени равно текущему с инвертированными цветами&lt;&#x2F;label&gt;&lt;br&gt;
&lt;label&gt;&lt;input type=&quot;radio&quot; name=&quot;prop&quot; value=&quot;self_inverse&quot; &#x2F;&gt; Инвертирование цвета правил приводит к самому себе&lt;&#x2F;label&gt;&lt;br&gt;
&lt;&#x2F;form&gt;
&lt;p&gt;Все свойства вычисляются для автоматов через 2 шага, то есть после чётного и нечётного хода. Мне кажется оценивать свойства автомата после 1 шага, не зная какой был до этого: чётный или нечётный не очень полезно, потому что вариантов становится слишком много, и свойств практически не остаётся. Некоторые свойства я объясню далее:&lt;&#x2F;p&gt;
&lt;p&gt;Самые скучные автоматы - &lt;strong&gt;сохраняющие текущее состояние&lt;&#x2F;strong&gt;. Это автоматы &lt;code&gt;0&lt;&#x2F;code&gt; и &lt;code&gt;23&lt;&#x2F;code&gt;. Они не делают ничего.&lt;&#x2F;p&gt;
&lt;p&gt;Чуть менее скучные автоматы — &lt;strong&gt;сохраняющие через два состояния&lt;&#x2F;strong&gt;. Относительно данного шага, их шаг в прошлое и шаг в будущее должны быть одинаковы. В итоге это выливается в то, что они приходят к изначальному состоянию максимум через 4 шага. Тут добавляется ещё два автомата: &lt;code&gt;7&lt;&#x2F;code&gt; и &lt;code&gt;16&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Ещё чуть менее-скучные автоматы — &lt;strong&gt;при зеркалировании приводящие сами в себя&lt;&#x2F;strong&gt;. То есть они не способны различать где лево, а где право. Тут к тривиальным &lt;code&gt;0&lt;&#x2F;code&gt; и &lt;code&gt;23&lt;&#x2F;code&gt; добавляются &lt;code&gt;2 и 21&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Одинаковые законы для симуляции назад и вперёд во времени&lt;&#x2F;strong&gt; — мне кажется это свойство аналогично &lt;a href=&quot;https:&#x2F;&#x2F;ru.wikipedia.org&#x2F;wiki&#x2F;T-%D1%81%D0%B8%D0%BC%D0%BC%D0%B5%D1%82%D1%80%D0%B8%D1%8F&quot;&gt;T-симметрии&lt;&#x2F;a&gt;, хотя я не знаю насколько справедливо проводить такие аналогии. К ним относится треугольный &lt;code&gt;1&lt;&#x2F;code&gt; и порождаемые им (далее мы увидим это).&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Правило для симуляции назад во времени равно текущему с инвертированными цветами&lt;&#x2F;strong&gt; — то же самое, что и предыдущее, только инвертированное. Это свойство интересно, ведь Криттеры именно такими и являются. То есть если в криттерах инвертировать всё поле, то там будут возникать глайдеры, состоящие не из заполненных клеток, а из пустых клеток, и эти глайдеры будут двигаться назад во времени, а не вперёд.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Инвертирование цвета правил приводит к самому себе&lt;&#x2F;strong&gt; — тут интересны автоматы &lt;code&gt;10&lt;&#x2F;code&gt; и &lt;code&gt;13&lt;&#x2F;code&gt;, потому что другими особыми свойствами они не обладают.&lt;&#x2F;p&gt;
&lt;p&gt;Давайте соберём список нетривиальных автоматов, которые обладают своим уникальным свойством:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;{1, 5, 6, 14}&lt;&#x2F;code&gt; не различают направление времени.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;{9, 17, 18, 22}&lt;&#x2F;code&gt; двигаются назад во времени для инвертированных цветов.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;{2, 21}&lt;&#x2F;code&gt; не различают лево и право.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;{10, 13}&lt;&#x2F;code&gt; не различают белый и чёрный.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h1 id=&quot;krasivye-avtomaty&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#krasivye-avtomaty&quot;&gt;#&lt;&#x2F;a&gt;Красивые автоматы&lt;&#x2F;h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1&lt;&#x2F;code&gt; похож на правило &lt;code&gt;30&lt;&#x2F;code&gt; для обычных автоматов, тоже формирует треугольники, только повёрнутые на 90°.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;2&lt;&#x2F;code&gt; похож на узор для рубашки.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;21&lt;&#x2F;code&gt; похож на &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Block_cellular_automaton#Tron&quot;&gt;правило Tron&lt;&#x2F;a&gt;.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;center&gt;
&lt;div class=&quot;container&quot;&gt;
&lt;div class=&quot;automata-col&quot;&gt;
&lt;span class=&quot;automata-name&quot;&gt;&lt;b&gt;1&lt;&#x2F;b&gt;&lt;&#x2F;span&gt;&lt;br&gt;
&lt;img class=&quot;pixelated any-img&quot; src=&quot;img&#x2F;1_both.png&quot;&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;automata-col&quot;&gt;
&lt;span class=&quot;automata-name&quot;&gt;&lt;b&gt;2&lt;&#x2F;b&gt;&lt;&#x2F;span&gt;&lt;br&gt;
&lt;img class=&quot;pixelated any-img&quot; src=&quot;img&#x2F;2_both.png&quot;&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;automata-col&quot;&gt;
&lt;span class=&quot;automata-name&quot;&gt;&lt;b&gt;21&lt;&#x2F;b&gt;&lt;&#x2F;span&gt;&lt;br&gt;
&lt;img class=&quot;pixelated any-img&quot; src=&quot;img&#x2F;21_both.png&quot;&gt;
&lt;&#x2F;div&gt;
&lt;&#x2F;div&gt;
&lt;&#x2F;center&gt;
&lt;h1 id=&quot;porozhdenie-pravil&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#porozhdenie-pravil&quot;&gt;#&lt;&#x2F;a&gt;Порождение правил&lt;&#x2F;h1&gt;
&lt;p&gt;Если вернуться в начало и посмотреть на все автоматы, то можно заметить, что для автомата &lt;code&gt;1&lt;&#x2F;code&gt;, &lt;code&gt;5&lt;&#x2F;code&gt; является его зеркальным отражением, &lt;code&gt;6&lt;&#x2F;code&gt; его инверсией, а &lt;code&gt;14&lt;&#x2F;code&gt; одновременно инверсией и зеркальным отражением.&lt;&#x2F;p&gt;
&lt;center&gt;
&lt;div class=&quot;container&quot;&gt;
&lt;div class=&quot;automata-col&quot;&gt;
&lt;span class=&quot;automata-name&quot;&gt;&lt;b&gt;1&lt;&#x2F;b&gt;&lt;&#x2F;span&gt;&lt;br&gt;
&lt;img class=&quot;pixelated any-img&quot; src=&quot;img&#x2F;1_both.png&quot;&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;automata-col&quot;&gt;
&lt;span class=&quot;automata-name&quot;&gt;&lt;b&gt;5&lt;&#x2F;b&gt;&lt;&#x2F;span&gt;&lt;br&gt;
&lt;img class=&quot;pixelated any-img&quot; src=&quot;img&#x2F;5_both.png&quot;&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;automata-col&quot;&gt;
&lt;span class=&quot;automata-name&quot;&gt;&lt;b&gt;6&lt;&#x2F;b&gt;&lt;&#x2F;span&gt;&lt;br&gt;
&lt;img class=&quot;pixelated any-img&quot; src=&quot;img&#x2F;6_both.png&quot;&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;automata-col&quot;&gt;
&lt;span class=&quot;automata-name&quot;&gt;&lt;b&gt;14&lt;&#x2F;b&gt;&lt;&#x2F;span&gt;&lt;br&gt;
&lt;img class=&quot;pixelated any-img&quot; src=&quot;img&#x2F;14_both.png&quot;&gt;
&lt;&#x2F;div&gt;
&lt;&#x2F;div&gt;
&lt;&#x2F;center&gt;
&lt;p&gt;Поэтому можно задаться вопросом: а какие автоматы можно вывести из каких при помощи различных операций над правилами?&lt;&#x2F;p&gt;
&lt;h2 id=&quot;trivial-nye-porozhdeniia&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#trivial-nye-porozhdeniia&quot;&gt;#&lt;sup&gt;2&lt;&#x2F;sup&gt;&lt;&#x2F;a&gt;Тривиальные порождения&lt;&#x2F;h2&gt;
&lt;p&gt;Возьмём преобразования правил, для которых мы можем точно сказать: да, это одно и то же правило, только немного-по другому.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Поменять местами лево и право. Будет обозначаться &lt;span style=&quot;color: green; font-weight: bold;&quot;&gt;Зелёным цветом&lt;&#x2F;span&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;Инвертировать белый на чёрный. Будет обозначаться &lt;span style=&quot;color: red; font-weight: bold;&quot;&gt;Красным цветом&lt;&#x2F;span&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;Инвертировать правила на симуляцию назад во времени. Будет обозначаться &lt;span style=&quot;font-weight: bold;&quot;&gt;Чёрным цветом&lt;&#x2F;span&gt;.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Тогда все правила будут иметь такие связи:&lt;&#x2F;p&gt;
&lt;div class=&quot;container&quot;&gt;
&lt;img class=&quot;svg&quot; src=&quot;svg&#x2F;3.svg&quot;&gt;
&lt;img class=&quot;svg&quot; src=&quot;svg&#x2F;4.svg&quot;&gt;
&lt;img class=&quot;svg&quot; src=&quot;svg&#x2F;5.svg&quot;&gt;
&lt;img class=&quot;svg&quot; src=&quot;svg&#x2F;6.svg&quot;&gt;
&lt;img class=&quot;svg&quot; src=&quot;svg&#x2F;7.svg&quot;&gt;
&lt;img class=&quot;svg&quot; src=&quot;svg&#x2F;8.svg&quot;&gt;
&lt;&#x2F;div&gt;
&lt;p&gt;Тут что-то не так. Почему-то &lt;code&gt;0&lt;&#x2F;code&gt; и &lt;code&gt;23&lt;&#x2F;code&gt; никак не связаны, как не связаны &lt;code&gt;2&lt;&#x2F;code&gt; и &lt;code&gt;21&lt;&#x2F;code&gt;, а ведь они одинаковы если пропустить нечётные шаги:&lt;&#x2F;p&gt;
&lt;center&gt;
&lt;div class=&quot;container&quot;&gt;
&lt;div class=&quot;automata-col&quot;&gt;
&lt;span class=&quot;automata-name&quot;&gt;&lt;b&gt;0&lt;&#x2F;b&gt;&lt;&#x2F;span&gt;&lt;br&gt;
&lt;img class=&quot;pixelated any-img&quot; src=&quot;img&#x2F;0_skip.png&quot;&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;automata-col&quot;&gt;
&lt;span class=&quot;automata-name&quot;&gt;&lt;b&gt;23&lt;&#x2F;b&gt;&lt;&#x2F;span&gt;&lt;br&gt;
&lt;img class=&quot;pixelated any-img&quot; src=&quot;img&#x2F;23_skip.png&quot;&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;automata-col&quot;&gt;
&lt;span class=&quot;automata-name&quot;&gt;&lt;b&gt;2&lt;&#x2F;b&gt;&lt;&#x2F;span&gt;&lt;br&gt;
&lt;img class=&quot;pixelated any-img&quot; src=&quot;img&#x2F;21_skip.png&quot;&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;automata-col&quot;&gt;
&lt;span class=&quot;automata-name&quot;&gt;&lt;b&gt;21&lt;&#x2F;b&gt;&lt;&#x2F;span&gt;&lt;br&gt;
&lt;img class=&quot;pixelated any-img&quot; src=&quot;img&#x2F;21_skip.png&quot;&gt;
&lt;&#x2F;div&gt;
&lt;&#x2F;div&gt;
&lt;&#x2F;center&gt;
&lt;p&gt;Зато автоматы &lt;code&gt;1&lt;&#x2F;code&gt;, &lt;code&gt;5&lt;&#x2F;code&gt;, &lt;code&gt;6&lt;&#x2F;code&gt;, &lt;code&gt;14&lt;&#x2F;code&gt; связаны между собой, и это радует:&lt;&#x2F;p&gt;
&lt;p&gt;Значит нам нужно придумать ещё какое-то правило для порождения нового правила, чтобы другие можно было связать.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;poluinversiia&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#poluinversiia&quot;&gt;#&lt;sup&gt;2&lt;&#x2F;sup&gt;&lt;&#x2F;a&gt;Полуинверсия&lt;&#x2F;h2&gt;
&lt;p&gt;Давайте добавим правило, которое реализуется полу-инверсией. Если правило можно представить в следующем виде: &lt;code&gt;[00, 01, 10, 11] → [11, 01, 0, 10]&lt;&#x2F;code&gt;, то обычная инверсия инвертирует биты с двух сторон, а полу-инверсия только с правой стороны. Будем обозначать её &lt;span style=&quot;color: purple; font-weight: bold;&quot;&gt;Фиолетовым цветом&lt;&#x2F;span&gt;. Тогда наши графы будут выглядеть следующим образом:&lt;&#x2F;p&gt;
&lt;div class=&quot;container&quot;&gt;
&lt;img class=&quot;svg&quot; src=&quot;svg&#x2F;9.svg&quot;&gt;
&lt;img class=&quot;svg&quot; src=&quot;svg&#x2F;10.svg&quot;&gt;
&lt;img class=&quot;svg&quot; src=&quot;svg&#x2F;11.svg&quot;&gt;
&lt;img class=&quot;svg&quot; src=&quot;svg&#x2F;12.svg&quot;&gt;
&lt;&#x2F;div&gt;
&lt;p&gt;Тут интересная особенность. Кластер правил, порождённых от &lt;code&gt;1&lt;&#x2F;code&gt;, связался с кластером правил, порождённых от &lt;code&gt;22&lt;&#x2F;code&gt;. Ну и они довольно похожи:&lt;&#x2F;p&gt;
&lt;center&gt;
&lt;div class=&quot;container&quot;&gt;
&lt;div class=&quot;automata-col&quot;&gt;
&lt;span class=&quot;automata-name&quot;&gt;&lt;b&gt;1&lt;&#x2F;b&gt;&lt;&#x2F;span&gt;&lt;br&gt;
&lt;img class=&quot;pixelated any-img&quot; src=&quot;img&#x2F;1_both.png&quot;&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;automata-col&quot;&gt;
&lt;span class=&quot;automata-name&quot;&gt;&lt;b&gt;22&lt;&#x2F;b&gt;&lt;&#x2F;span&gt;&lt;br&gt;
&lt;img class=&quot;pixelated any-img&quot; src=&quot;img&#x2F;22_both.png&quot;&gt;
&lt;&#x2F;div&gt;
&lt;&#x2F;div&gt;
&lt;&#x2F;center&gt;
&lt;p&gt;А кластер правил, порождённых от &lt;code&gt;3&lt;&#x2F;code&gt;, связался с кластером от &lt;code&gt;20&lt;&#x2F;code&gt;. Они выглядят похожим образом при пропуске нечётных шагов:&lt;&#x2F;p&gt;
&lt;center&gt;
&lt;div class=&quot;container&quot;&gt;
&lt;div class=&quot;automata-col&quot;&gt;
&lt;span class=&quot;automata-name&quot;&gt;&lt;b&gt;3&lt;&#x2F;b&gt;&lt;&#x2F;span&gt;&lt;br&gt;
&lt;img class=&quot;pixelated any-img&quot; src=&quot;img&#x2F;3_skip.png&quot;&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;automata-col&quot;&gt;
&lt;span class=&quot;automata-name&quot;&gt;&lt;b&gt;20&lt;&#x2F;b&gt;&lt;&#x2F;span&gt;&lt;br&gt;
&lt;img class=&quot;pixelated any-img&quot; src=&quot;img&#x2F;20_skip.png&quot;&gt;
&lt;&#x2F;div&gt;
&lt;&#x2F;div&gt;
&lt;&#x2F;center&gt;
&lt;p&gt;Если посмотреть на то как новая операция связывает правила, то можно сказать что она просто делает &lt;code&gt;23-x&lt;&#x2F;code&gt;. То есть с этой операцией мы можем получить любое правило с &lt;code&gt;12&lt;&#x2F;code&gt; включительно, если нам известны все правила до 11. Это хорошо, потому что можно выкинуть половину правил и знать что она будет симметрична первой половине относительно полу-инверсии.&lt;&#x2F;p&gt;
&lt;p&gt;Но у нас всё ещё не связаны правила &lt;code&gt;2&lt;&#x2F;code&gt; и &lt;code&gt;10&lt;&#x2F;code&gt;, которые просто идентичны без нечётных шагов:&lt;&#x2F;p&gt;
&lt;center&gt;
&lt;div class=&quot;container&quot;&gt;
&lt;div class=&quot;automata-col&quot;&gt;
&lt;span class=&quot;automata-name&quot;&gt;&lt;b&gt;2&lt;&#x2F;b&gt;&lt;&#x2F;span&gt;&lt;br&gt;
&lt;img class=&quot;pixelated any-img&quot; src=&quot;img&#x2F;2_skip.png&quot;&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;automata-col&quot;&gt;
&lt;span class=&quot;automata-name&quot;&gt;&lt;b&gt;10&lt;&#x2F;b&gt;&lt;&#x2F;span&gt;&lt;br&gt;
&lt;img class=&quot;pixelated any-img&quot; src=&quot;img&#x2F;10_skip.png&quot;&gt;
&lt;&#x2F;div&gt;
&lt;&#x2F;div&gt;
&lt;&#x2F;center&gt;
&lt;h2 id=&quot;strannaia-operatsiia&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#strannaia-operatsiia&quot;&gt;#&lt;sup&gt;2&lt;&#x2F;sup&gt;&lt;&#x2F;a&gt;Странная операция&lt;&#x2F;h2&gt;
&lt;p&gt;Я не смог найти комбинацию из обращения времени, отзеркаливания, инверсии, их половинок и всех их комбинаций, чтобы связать &lt;code&gt;2&lt;&#x2F;code&gt; и &lt;code&gt;10&lt;&#x2F;code&gt; правило. Единственное что я нашёл, это операцию: поменять местами 0 и 1 элемент, и поменять местами 2 и 3 элемент в массиве правила (обозначается квадратными скобками в таблице). Назовём это &lt;strong&gt;странной операцией&lt;&#x2F;strong&gt;, и будем обозначать &lt;span style=&quot;color: cyan; font-weight: bold;&quot;&gt;Циановым цветом&lt;&#x2F;span&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Тогда у нас получается следующий набор графов:&lt;&#x2F;p&gt;
&lt;div class=&quot;container&quot;&gt;
&lt;img class=&quot;svg&quot; src=&quot;svg&#x2F;13.svg&quot;&gt;
&lt;img class=&quot;svg&quot; src=&quot;svg&#x2F;14.svg&quot;&gt;
&lt;img class=&quot;svg&quot; src=&quot;svg&#x2F;15.svg&quot;&gt;
&lt;img class=&quot;svg&quot; src=&quot;svg&#x2F;16.svg&quot;&gt;
&lt;&#x2F;div&gt;
&lt;p&gt;Ура! Теперь у нас связаны тривиальные автоматы &lt;code&gt;{0, 7, 16, 23}&lt;&#x2F;code&gt; и чуть более сложные, но тоже очень простые &lt;code&gt;{2, 10, 13, 21}&lt;&#x2F;code&gt;. А что касается остальных автоматов, с ними не произошло ничего особенного. Что уже было связано прежними операциями, так и осталось связано ими.&lt;&#x2F;p&gt;
&lt;p&gt;Итого у нас получается 4 группы автоматов, которые можно получить довольно простыми операциями, которые не очень сильно меняют поведение автомата. Можно сказать что если мы изучим свойства автомата &lt;code&gt;1&lt;&#x2F;code&gt;, то по идее можем эктраполировать его свойства с учётом полу-инверсии на &lt;code&gt;22&lt;&#x2F;code&gt; автомат.&lt;&#x2F;p&gt;
&lt;p&gt;Правда мне эта &lt;strong&gt;странная операция&lt;&#x2F;strong&gt; не нравится совсем. Ведь я не понимаю что будет если её обобщить на:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Автоматы с большим размером блока (от 3 и больше)&lt;&#x2F;li&gt;
&lt;li&gt;Автоматы с большим числом цветов (от 3 и больше)&lt;&#x2F;li&gt;
&lt;li&gt;Автоматы с большей размерностью (от 2 и больше)&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Поэтому если у вас есть идеи что с этим можно сделать — пишите.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;2d-vremia&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#2d-vremia&quot;&gt;#&lt;&#x2F;a&gt;2D время&lt;&#x2F;h1&gt;
&lt;p&gt;Следующее исследование свойств вдохновлено статьёй о том как создать 2D время для необратимых клеточных автоматов:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http:&#x2F;&#x2F;dmishin.blogspot.com&#x2F;2014&#x2F;06&#x2F;cellular-automata-with-2-temporal.html&quot;&gt;CELLULAR AUTOMATA WITH 2 TEMPORAL DIMENSIONS&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Там автор предлагает идею 2D времени, которая требует иметь две функции \(f, g\), которые дают одинаковый результат независимо от порядка их применения \(f(g(x)) = g(f(x))\). Поэтому можно проверить все автоматы и узнать кто с кем коммутирует. Прежде всего надо сказать что автоматы &lt;code&gt;{0, 23, 7, 16}&lt;&#x2F;code&gt; коммутируют со всеми, а они совсем тривиальны и не интересны, поэтому я исключил их из графа. И у меня получился следующим результат:&lt;&#x2F;p&gt;
&lt;div class=&quot;container&quot;&gt;
&lt;img class=&quot;svg&quot; src=&quot;svg&#x2F;commute0.svg&quot;&gt;
&lt;img class=&quot;svg&quot; src=&quot;svg&#x2F;commute1.svg&quot;&gt;
&lt;img class=&quot;svg&quot; src=&quot;svg&#x2F;commute2.svg&quot;&gt;
&lt;&#x2F;div&gt;
&lt;p&gt;Тут задействованы правила только из групп, порождённых &lt;code&gt;2&lt;&#x2F;code&gt; и &lt;code&gt;3&lt;&#x2F;code&gt;, но нет автоматов, порождённых от треугольной &lt;code&gt;1&lt;&#x2F;code&gt;, что довольно печально.&lt;&#x2F;p&gt;
&lt;p&gt;Получается примерно тот же результат, как и в той статье, что между собой коммутируют только довольно скучные автоматы, не считая тривиальных.&lt;&#x2F;p&gt;
&lt;p&gt;То что можно рисовать графы между правилами было вдохновлено этой статьёй:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http:&#x2F;&#x2F;dmishin.blogspot.com&#x2F;2016&#x2F;01&#x2F;graph-of-commuting-elementary-cellular.html&quot;&gt;GRAPH OF COMMUTING ELEMENTARY CELLULAR AUTOMATA&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Для вычисления того коммутируют два правила или нет, я просто беру очень длинную строку на 10к бит, и проверяю формулу &lt;code&gt;f(g(x)) = g(f(x))&lt;&#x2F;code&gt; на ней одной. Так что мои результаты не идеальны, но вероятность ошибки крайне мала.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;iskhodniki&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#iskhodniki&quot;&gt;#&lt;&#x2F;a&gt;Исходники&lt;&#x2F;h1&gt;
&lt;p&gt;Исходники для вычисления картинок, свойств и графов для этой статьи находятся в репозитории: &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;optozorax&#x2F;time_2d_inversible_automata&quot;&gt;optozorax&#x2F;time_2d_inversible_automata&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;dal-neishaia-rabota&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#dal-neishaia-rabota&quot;&gt;#&lt;&#x2F;a&gt;Дальнейшая работа&lt;&#x2F;h1&gt;
&lt;p&gt;Мне кажется должны найтись очень интересные правила для:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Обратимых одномерных автоматов с &lt;strong&gt;3&lt;&#x2F;strong&gt; цветами и размером блока &lt;strong&gt;2&lt;&#x2F;strong&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Обратимых одномерных автоматов с &lt;strong&gt;2&lt;&#x2F;strong&gt; цветами и размером блока &lt;strong&gt;3&lt;&#x2F;strong&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;В первом случае получается 3²! = 362_880, а во втором 2³! = 40_320 автоматов, что тоже очень много...&lt;&#x2F;p&gt;
&lt;p&gt;Тут придётся уже писать софт, чтобы в графах искать компоненты связности. И больше раскидывать мозгами. Но думаю что количество групп, из которых можно вывести всё остальное, должно быть не таким большим. А далее уже можно исследовать группы на коммутативность. Может среди этих вариантов найдутся интересные правила, для которых можно образовать двумерное время.&lt;&#x2F;p&gt;
&lt;script&gt;
function highlight(name) {
  let elements = document.getElementsByClassName(name);
  for (var i = elements.length - 1; i &gt;= 0; i--) {
    elements[i].style[&quot;background-color&quot;] = &#x27;rgba(255,41,43,0.20)&#x27;;
  }
}
function leave(name) {
  let elements = document.getElementsByClassName(name);
  for (var i = elements.length - 1; i &gt;= 0; i--) {
    elements[i].style[&quot;background-color&quot;] = &quot;rgba(39,41,43,0.03)&quot;;
  }
}
function show(skip_img, both_img) {
  let elements = document.getElementsByClassName(&quot;skip-img&quot;);
  for (var i = elements.length - 1; i &gt;= 0; i--) {
    elements[i].style.display = skip_img;
  }

  elements = document.getElementsByClassName(&quot;both-img&quot;);
  for (var i = elements.length - 1; i &gt;= 0; i--) {
    elements[i].style.display = both_img;
  }
}

show(&quot;none&quot;, &quot;block&quot;);

let rad = document.properties_radio.prop;
let prev = { value: &#x27;all&#x27; };
for (var i = 0; i &lt; rad.length; i++) {
    rad[i].addEventListener(&#x27;change&#x27;, function() {
        if (this !== prev) {
            leave(prev.value);
            highlight(this.value);
        }
        prev = this;
    });
}

document.getElementById(&#x27;img_intermediate&#x27;).addEventListener(&#x27;change&#x27;, function() {
    if (this.checked) {
      show(&quot;none&quot;, &quot;block&quot;);
    } else {
      show(&quot;block&quot;, &quot;none&quot;);
    }
});
&lt;&#x2F;script&gt;
</description>
        </item>
        <item>
            <title>Двойки не существует</title>
            <pubDate>Sun, 06 Jun 2021 00:00:00 +0000</pubDate>
            <link>https://testzorax.github.io/p/two-doesnt-exists/</link>
            <guid>https://testzorax.github.io/p/two-doesnt-exists/</guid>
            <description>&lt;p&gt;У людей есть такое когнитивное искажение, которое мешает им принимать абстрактные концепции только из-за того что реализации этих концепций нет в реальном мире.&lt;&#x2F;p&gt;
&lt;p&gt;Примеры фраз: &lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;4D не существует потому что мы живём в трёхмерном мире.&lt;&#x2F;li&gt;
&lt;li&gt;Не может быть геометрического 4D пространства, потому что существует только пространство-время.&lt;&#x2F;li&gt;
&lt;li&gt;Порталы не могут двигаться, потому что они обязательно червоточины, которые типо могут существовать.&lt;&#x2F;li&gt;
&lt;li&gt;Отрицательных чисел не существует, потому что мы не можем насыпать в мешок -3 камня. (особо запущенный случай)&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Самое интересное из этих утверждений это второе. Оно как бы показывает что собеседник осведомлён о текущем состоянии науки, но в то же время подвергается этому искажению. Потому что говорить что 4D — это исключительно пространство-время, такое же бессмысленное утверждение, как говорить что число 2 обозначает только те 2 камня, но не 2 джоуля, не 2 фотона, не 2 бита, не 2 икса. Число 2 — куда более широкое понятие, чем его конкретная реализация в виде двух конкретных объектов.&lt;&#x2F;p&gt;
&lt;p&gt;А утверждать, что 4D не существует, настолько же бессмысленно, как и утверждать что числа 2 не существует. 4D — абстрактная концепция, которая не зависит от нашего мира.&lt;&#x2F;p&gt;
&lt;p&gt;Надо принять что бывает полезно рассуждать об абстрактных вещах, которые никак не могут существовать в нашем мире.&lt;&#x2F;p&gt;
&lt;p&gt;Тогда где граница существования абстрактных объектов, если они все и существуют и не существуют?&lt;&#x2F;p&gt;
&lt;p&gt;Возьмём i² = -1. Оно существует? Нет, если мы хотим найти его в множестве ℝ. А если мы вводим его как новый объект, то вполне себе красиво и существует.&lt;&#x2F;p&gt;
&lt;p&gt;А может ли новый объект не существовать в математике? Да, если они приводит к противоречиям. Например, машина из &lt;a href=&quot;https:&#x2F;&#x2F;ru.wikipedia.org&#x2F;wiki&#x2F;%D0%9F%D1%80%D0%BE%D0%B1%D0%BB%D0%B5%D0%BC%D0%B0_%D0%BE%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BA%D0%B8&quot;&gt;проблемы останова&lt;&#x2F;a&gt; не существует математически, потому что она сама себе противоречит. Аналогично с &lt;a href=&quot;https:&#x2F;&#x2F;ru.wikipedia.org&#x2F;wiki&#x2F;%D0%9F%D0%B0%D1%80%D0%B0%D0%B4%D0%BE%D0%BA%D1%81_%D0%A0%D0%B0%D1%81%D1%81%D0%B5%D0%BB%D0%B0#%D0%9F%D0%B0%D1%80%D0%B0%D0%B4%D0%BE%D0%BA%D1%81_%D0%B1%D1%80%D0%B0%D0%B4%D0%BE%D0%B1%D1%80%D0%B5%D1%8F.&quot;&gt;парадоксом Брадобрея&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Слово «существовать» можно определить следующим списком:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Либо имеет конкретную реализацию в физическом мире.&lt;&#x2F;li&gt;
&lt;li&gt;Либо не противодит к противоречиям.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Так что если вам говорят что что-то абстрактное не существует, напомните им что и двойки тоже не существует.&lt;&#x2F;p&gt;
&lt;div class=&quot;magnifier-container img-one&quot;&gt;
&lt;img
    class=&quot;not-default full-screen-img&quot;
    width=&quot;720&quot;
    height=&quot;720&quot;
    src=&quot;&amp;#x2F;processed_images&amp;#x2F;616cbcd31c929d2100.webp&quot; 
    onclick=&quot;full_screen(&#x27;two-doesnt-exists.png&#x27;)&quot;
    onauxclick=&quot;full_screen_new_page(&#x27;two-doesnt-exists.png&#x27;)&quot;&gt;
&lt;div class=&quot;magnifier-display&quot;&gt;
&lt;img class=&quot;magnifier&quot; src=&quot;&#x2F;ico&#x2F;magnifier.svg&quot;&gt;&lt;div class=&quot;magnifier-info&quot;&gt;×1&lt;br&gt;png&lt;&#x2F;div&gt;
&lt;&#x2F;div&gt;
&lt;&#x2F;div&gt;
</description>
        </item>
        <item>
            <title>Как записать перестановку в число</title>
            <pubDate>Sun, 08 Nov 2020 00:00:00 +0000</pubDate>
            <link>https://testzorax.github.io/p/permutation-into-number/</link>
            <guid>https://testzorax.github.io/p/permutation-into-number/</guid>
            <description>&lt;p&gt;Для предстоящей программки, где можно запускать обратимые клеточные автоматы я хочу сделать возможность задавать любые правила. Как я описывал в &lt;a href=&quot;&#x2F;critters&quot;&gt;посте про Critters&lt;&#x2F;a&gt;, любая перестановка массива от &lt;code&gt;0&lt;&#x2F;code&gt; до &lt;code&gt;N&lt;&#x2F;code&gt; является корректным правилом. Значит должна быть возможность задавать перестановку в виде чего-то, что можно скопипастить и вставить в программу. &lt;&#x2F;p&gt;
&lt;p&gt;На &lt;a href=&quot;https:&#x2F;&#x2F;dmishin.github.io&#x2F;js-revca&#x2F;index.html&quot;&gt;одном сайте с обратимыми автоматами&lt;&#x2F;a&gt; перестановка задаётся так:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;0,2,8,3,1,5,6,7,4,9,10,11,12,13,14,15&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;По мне это довольно скучно и не очень удобно.&lt;&#x2F;p&gt;
&lt;p&gt;Поэтому я придумал, что это надо отображать одним числом, которое можно менять на &lt;code&gt;+1&lt;&#x2F;code&gt;, &lt;code&gt;-1&lt;&#x2F;code&gt;, и оно будет корректным. А затем вообще переводить это число в систему счисления с основанием &lt;code&gt;64&lt;&#x2F;code&gt;, чтобы оно было ещё короче.&lt;&#x2F;p&gt;
&lt;p&gt;Итак, для массива из &lt;code&gt;N&lt;&#x2F;code&gt; различных элементов существует &lt;code&gt;N!&lt;&#x2F;code&gt; возможных вариантов перестановки. Значит можно как-то пронумеровать каждую перестановку одним числом. И если сделать так, то пользователь сможет играться, меняя числа, у него всегда будет получаться корректное правило. Если он, конечно, не задаст число больше &lt;code&gt;N!&lt;&#x2F;code&gt;, но не допустить такую ошибку довольно легко.&lt;&#x2F;p&gt;
&lt;p&gt;Итак, перестановка, показанная вначале может быть записана числом как:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;125023449600&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Или если же это число перевести в &lt;code&gt;64&lt;&#x2F;code&gt;-ричную систему счисления:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;08D+rQ1&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Я сделал маленькую библиотечку чтобы вычислять все эти вещи: &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;optozorax&#x2F;permutation_string&#x2F;blob&#x2F;master&#x2F;src&#x2F;lib.rs&quot;&gt;permutation_string&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Всеми этими тремя способами в моей программе можно будет задавать правила.&lt;&#x2F;p&gt;
&lt;p&gt;Так же я хочу сделать GUI, чтобы правила можно было перетаскивать мышкой, и чтобы рядом писались все эти данные. Благо на &lt;a href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;fedor_games&#x2F;status&#x2F;1313119249146281986&quot;&gt;megaui&lt;&#x2F;a&gt; в &lt;a href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;fedor_games&#x2F;status&#x2F;1313219605981204482&quot;&gt;macroquad&lt;&#x2F;a&gt; сделать это довольно легко. Не знал кстати что Immediate Mode GUI такой простой о_О. Какой-то диссонанс происходит после того как ты делал гуй на всех этих коллбэках. Попробуйте почитать код, и потыкаться.&lt;&#x2F;p&gt;
&lt;p&gt;А теперь я расскажу как именно можно превратить перестановку в одно число.&lt;&#x2F;p&gt;
&lt;p&gt;Пусть у нас есть перестановка &lt;code&gt;А&lt;&#x2F;code&gt; из пяти элементов: &lt;code&gt;[4,1,2,3,0]&lt;&#x2F;code&gt;. Главное свойство любой перестановки - в ней все числа уникальны. Значит можно преобразовать этот массив в немного другой.&lt;&#x2F;p&gt;
&lt;p&gt;Пусть у нас ещё есть такой массив &lt;code&gt;Б&lt;&#x2F;code&gt;: &lt;code&gt;[0,1,2,3,4]&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Далее берём нашу перестановку, и говорим по какому индексу находится первый её элемент? &lt;code&gt;4&lt;&#x2F;code&gt; находится по индексу &lt;code&gt;4&lt;&#x2F;code&gt;, так и записываем в массив &lt;code&gt;Ц&lt;&#x2F;code&gt;. Удаляем из массива &lt;code&gt;Б&lt;&#x2F;code&gt; и массива &lt;code&gt;А&lt;&#x2F;code&gt; число &lt;code&gt;4&lt;&#x2F;code&gt;. &lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;А = [1,2,3,0]. Б = [0,1,2,3]. Ц = [4].&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Берём следующее число из &lt;code&gt;А&lt;&#x2F;code&gt;: &lt;code&gt;1&lt;&#x2F;code&gt;. По какому индексу находится? &lt;code&gt;1&lt;&#x2F;code&gt;. Так и записываем, удаляем из &lt;code&gt;Б&lt;&#x2F;code&gt; и &lt;code&gt;А&lt;&#x2F;code&gt; эти элементы. &lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;А = [2,3,0]. Б = [0,2,3]. Ц = [4,1].&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;И теперь начинается самое интересное. Берём следующее число из &lt;code&gt;А&lt;&#x2F;code&gt;: &lt;code&gt;2&lt;&#x2F;code&gt;. Оно находится по индексу &lt;code&gt;1&lt;&#x2F;code&gt;. Так и записываем, и удаляем из &lt;code&gt;А&lt;&#x2F;code&gt; и &lt;code&gt;Б&lt;&#x2F;code&gt;. &lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;А = [3,0]. Б = [0,3]. Ц = [4,1,1].&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Ну и таким образом у нас в итоге получится: &lt;code&gt;А = []. Б = []. Ц = [4,1,1,1,0]&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Что интересного в массиве &lt;code&gt;Ц&lt;&#x2F;code&gt;? У него в каждом следующем элементе максимальное возможное число уменьшается на &lt;code&gt;1&lt;&#x2F;code&gt;. То есть максимальный &lt;code&gt;Ц = [4,3,2,1,0]&lt;&#x2F;code&gt; возможен для перестановки: &lt;code&gt;[4,3,2,1,0]&lt;&#x2F;code&gt;. А &lt;code&gt;Ц = [0,0,0,0,0]&lt;&#x2F;code&gt; получается для перестановки &lt;code&gt;[0,1,2,3,4]&lt;&#x2F;code&gt;. &lt;&#x2F;p&gt;
&lt;p&gt;Получается в &lt;code&gt;Ц&lt;&#x2F;code&gt; у нас хранятся цифры с необычной системой счисления, разной для каждого разряда. Ну и далее можно использовать &lt;code&gt;Ц&lt;&#x2F;code&gt; чтобы получить номер перестановки:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;0*0! + 1*1! + 1*2! + 1*3! + 4*4! = 105.&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Получается это число находится в промежутке от &lt;code&gt;0&lt;&#x2F;code&gt; до &lt;code&gt;N!-1&lt;&#x2F;code&gt;. Вот так мы и пронумеровали каждую перестановку.&lt;&#x2F;p&gt;
&lt;p&gt;Кстати несложно модифицировать алгоритм, чтобы обрабатывать перестановки с повторяющимися элементами.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;Говорят что я переизобрёл &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Factorial_number_system&quot;&gt;факториальную Систему Счисления&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>Float — это динамическая типизация на уровне процессора</title>
            <pubDate>Sat, 20 Jun 2020 00:00:00 +0000</pubDate>
            <link>https://testzorax.github.io/p/typed-float/</link>
            <guid>https://testzorax.github.io/p/typed-float/</guid>
            <description>&lt;h1 id=&quot;vvedenie&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#vvedenie&quot;&gt;#&lt;&#x2F;a&gt;Введение&lt;&#x2F;h1&gt;
&lt;p&gt;В этой статье предполагается что вы знакомы с языком Rust, и знаете что такое алгебраические типы данных (ADT).&lt;&#x2F;p&gt;
&lt;p&gt;Сравните эти два примера кода:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;js&quot; style=&quot;background-color:#f5f5f5;color:#1f1f1f;&quot; class=&quot;language-js &quot;&gt;&lt;code class=&quot;language-js&quot; data-lang=&quot;js&quot;&gt;&lt;span style=&quot;color:#668f14;&quot;&gt;function &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c23f31;&quot;&gt;something&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#5597d6;&quot;&gt;a&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#72ab00;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#72ab00;&quot;&gt;typeof &lt;&#x2F;span&gt;&lt;span style=&quot;color:#5597d6;&quot;&gt;a &lt;&#x2F;span&gt;&lt;span style=&quot;color:#72ab00;&quot;&gt;=== &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d07711;&quot;&gt;&amp;quot;number&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#72ab00;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#5597d6;&quot;&gt;a&lt;&#x2F;span&gt;&lt;span style=&quot;color:#72ab00;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b3933a;&quot;&gt;3 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#72ab00;&quot;&gt;+ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b3933a;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#72ab00;&quot;&gt;else if &lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#72ab00;&quot;&gt;typeof &lt;&#x2F;span&gt;&lt;span style=&quot;color:#5597d6;&quot;&gt;a &lt;&#x2F;span&gt;&lt;span style=&quot;color:#72ab00;&quot;&gt;=== &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d07711;&quot;&gt;&amp;quot;string&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#72ab00;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b3933a;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#f5f5f5;color:#1f1f1f;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#668f14;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c23f31;&quot;&gt;something&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#5597d6;&quot;&gt;a&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#668f14;&quot;&gt;f64&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#668f14;&quot;&gt;f64 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#72ab00;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; a.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b39f04;&quot;&gt;is_nan&lt;&#x2F;span&gt;&lt;span&gt;() {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b3933a;&quot;&gt;0.0
&lt;&#x2F;span&gt;&lt;span&gt;    } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#72ab00;&quot;&gt;else if !&lt;&#x2F;span&gt;&lt;span&gt;a.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b39f04;&quot;&gt;is_finite&lt;&#x2F;span&gt;&lt;span&gt;() {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b3933a;&quot;&gt;1.0
&lt;&#x2F;span&gt;&lt;span&gt;    } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#72ab00;&quot;&gt;else if&lt;&#x2F;span&gt;&lt;span&gt; a &lt;&#x2F;span&gt;&lt;span style=&quot;color:#72ab00;&quot;&gt;== &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b3933a;&quot;&gt;0.0 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b3933a;&quot;&gt;1.0
&lt;&#x2F;span&gt;&lt;span&gt;    } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#72ab00;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b3933a;&quot;&gt;1 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#72ab00;&quot;&gt;&#x2F;&lt;&#x2F;span&gt;&lt;span&gt; a.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b39f04;&quot;&gt;abs&lt;&#x2F;span&gt;&lt;span&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Казалось, бы, два совершенно разных языка, а код выглядит так одинаково: всё &lt;strong&gt;валидируется&lt;&#x2F;strong&gt; (кто не в теме, надо &lt;a href=&quot;https:&#x2F;&#x2F;habr.com&#x2F;ru&#x2F;post&#x2F;498042&#x2F;&quot;&gt;парсить, а не валидировать&lt;&#x2F;a&gt;). Да, всё дело в том, что вещественные числа - это, по сути, динамическая типизация на уровне процессора. У нас в переменной вещественного числа может храниться множество состояний, которые мы должны проверять, если хотим узнать что там хранится. Так же там присутствует неявное приведение типов из &amp;quot;разных&amp;quot; категорий, например &lt;code&gt;1.0 + NaN = NaN&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Что люди сделали с динамической типизацией в JavaScript? Они придумали TypeScript. И стало хорошо. Получается то же самое можно сделать с вещественными числами?&lt;&#x2F;p&gt;
&lt;h1 id=&quot;nan&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#nan&quot;&gt;#&lt;&#x2F;a&gt;NaN&lt;&#x2F;h1&gt;
&lt;p&gt;Самая базовая проблема вещественных чисел - это &lt;code&gt;NaN&lt;&#x2F;code&gt;. Он обладает очень противным свойством: не равен самому себе.&lt;&#x2F;p&gt;
&lt;p&gt;Из-за этого мы в Rust&#x27;е не можем хранить вещественные числа в дереве, сортировать массив с ними, то есть реализовывать трейты &lt;code&gt;Eq&lt;&#x2F;code&gt;, &lt;code&gt;Ord&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Если вытащить из вещественного числа &lt;code&gt;NaN&lt;&#x2F;code&gt;, то оно сразу становится хорошим. Схематически это можно обозначить так:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#f5f5f5;color:#1f1f1f;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#668f14;&quot;&gt;enum &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c23f31;&quot;&gt;Float &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    NaN,
&lt;&#x2F;span&gt;&lt;span&gt;    NotNanFloat(NotNanFloat),
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#668f14;&quot;&gt;enum &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c23f31;&quot;&gt;NotNanFloat &lt;&#x2F;span&gt;&lt;span&gt;{ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#7f8989;&quot;&gt;&#x2F;* ... *&#x2F; &lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#668f14;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;Eq &lt;&#x2F;span&gt;&lt;span style=&quot;color:#72ab00;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c23f31;&quot;&gt;NotNanFloat &lt;&#x2F;span&gt;&lt;span&gt;{ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#7f8989;&quot;&gt;&#x2F;* ... *&#x2F; &lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#668f14;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;Ord &lt;&#x2F;span&gt;&lt;span style=&quot;color:#72ab00;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c23f31;&quot;&gt;NotNanFloat &lt;&#x2F;span&gt;&lt;span&gt;{ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#7f8989;&quot;&gt;&#x2F;* ... *&#x2F; &lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;И мы можем записать в массиве, что храним только &lt;code&gt;NotNanFloat&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Когда я писал &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;optozorax&#x2F;confidence&quot;&gt;github:confidence&lt;&#x2F;a&gt;, мне очень не хватало возможности матчиться по такой структуре данных, или говорить что я принимаю только &lt;code&gt;NotNanFloat&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Правда, появляется проблема, что некоторые операции над &lt;code&gt;NotNanFloat&lt;&#x2F;code&gt; позволяют прийти к &lt;code&gt;NaN&lt;&#x2F;code&gt;, например: умножение бесконечности на ноль, деление на ноль. Получается, нам после любых арифметических вычислений нужно приводить тип из более широкого &lt;code&gt;Float&lt;&#x2F;code&gt; обратно к &lt;code&gt;NotNanFloat&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#f5f5f5;color:#1f1f1f;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#668f14;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; a: NotNanFloat &lt;&#x2F;span&gt;&lt;span style=&quot;color:#72ab00;&quot;&gt;= ...&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#668f14;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; b: NotNanFloat &lt;&#x2F;span&gt;&lt;span style=&quot;color:#72ab00;&quot;&gt;= ...&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#668f14;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; c: Float &lt;&#x2F;span&gt;&lt;span style=&quot;color:#72ab00;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; a &lt;&#x2F;span&gt;&lt;span style=&quot;color:#72ab00;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt; b &lt;&#x2F;span&gt;&lt;span style=&quot;color:#72ab00;&quot;&gt;&#x2F; &lt;&#x2F;span&gt;&lt;span&gt;(a &lt;&#x2F;span&gt;&lt;span style=&quot;color:#72ab00;&quot;&gt;+&lt;&#x2F;span&gt;&lt;span&gt; b);
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#668f14;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; d: NotNanFloat &lt;&#x2F;span&gt;&lt;span style=&quot;color:#72ab00;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; c.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b39f04;&quot;&gt;try_into&lt;&#x2F;span&gt;&lt;span&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b39f04;&quot;&gt;unwrap&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;С одной стороны это даже хорошо, потому что мы не будем хранить фигню у себя в массивах, и в конце не получим что у нас огромная матрица перемножалась 100 раз с &lt;code&gt;NaN&lt;&#x2F;code&gt;&#x27;ами, а получим ошибку намного раньше.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;prodolzhenie-bezumiia&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#prodolzhenie-bezumiia&quot;&gt;#&lt;&#x2F;a&gt;Продолжение безумия&lt;&#x2F;h1&gt;
&lt;p&gt;Можно пойти дальше и ещё сильнее разделить вещественные числа:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#f5f5f5;color:#1f1f1f;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#668f14;&quot;&gt;enum &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c23f31;&quot;&gt;NotNanFloat &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    InfiniteFloat(InfiniteFloat),
&lt;&#x2F;span&gt;&lt;span&gt;    FiniteFloat(FiniteFloat),
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#668f14;&quot;&gt;enum &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c23f31;&quot;&gt;InfiniteFloat &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    Negative,
&lt;&#x2F;span&gt;&lt;span&gt;    Positive,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#668f14;&quot;&gt;enum &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c23f31;&quot;&gt;FiniteFloat &lt;&#x2F;span&gt;&lt;span&gt;{ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#7f8989;&quot;&gt;&#x2F;* ... *&#x2F; &lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Но в этом уже нет такой серьёзной причины как в отделении от &lt;code&gt;NaN&lt;&#x2F;code&gt;&#x27;а. Такое разделение можно использовать для более чёткого контроля типов данных на этапе компиляции.&lt;&#x2F;p&gt;
&lt;p&gt;Например, можно создать тип &lt;code&gt;FloatFrom0ToInf&lt;&#x2F;code&gt;, который содержит все положительные числа и включая ноль. И затем сказать что &lt;code&gt;fn div_one(down: FloatFrom0ToInf) -&amp;gt; FloatFrom0ToInf&lt;&#x2F;code&gt;. Ну и вообще рассчитать все операции друг из друга, и записать это на системах типов.&lt;&#x2F;p&gt;
&lt;p&gt;Либо же &lt;code&gt;NotNanFloat&lt;&#x2F;code&gt; можно расписать так:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#f5f5f5;color:#1f1f1f;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#668f14;&quot;&gt;enum &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c23f31;&quot;&gt;NotNanFloat &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    PositiveFloat(PositiveFloat),
&lt;&#x2F;span&gt;&lt;span&gt;    NegativeFloat(NegativeFloat),
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#668f14;&quot;&gt;enum &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c23f31;&quot;&gt;PositiveFloat &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    Infinity,
&lt;&#x2F;span&gt;&lt;span&gt;    FinitePositiveFloat(FinitePositiveFloat),
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#668f14;&quot;&gt;enum &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c23f31;&quot;&gt;FinitePositiveFloat &lt;&#x2F;span&gt;&lt;span&gt;{ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#7f8989;&quot;&gt;&#x2F;* ... *&#x2F; &lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Здесь можно сделать метод: &lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#f5f5f5;color:#1f1f1f;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#668f14;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c23f31;&quot;&gt;mul&lt;&#x2F;span&gt;&lt;span&gt;(PositiveFiniteFloat, PositiveFiniteFloat) -&amp;gt; PositiveFloat;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Или надо отделить ноль от всего остального, и можно получить деление, которое не должно вызывать &lt;code&gt;NaN&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#f5f5f5;color:#1f1f1f;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#668f14;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c23f31;&quot;&gt;div&lt;&#x2F;span&gt;&lt;span&gt;(FiniteFloat, NonZeroFiniteFloat) -&amp;gt; NonZeroFiniteFloat;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;А ещё можно иметь крутые сообщения об ошибках, когда ты пытаешься преобразовать более широкий тип к более маленькому:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#f5f5f5;color:#1f1f1f;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#668f14;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; a: Float &lt;&#x2F;span&gt;&lt;span style=&quot;color:#72ab00;&quot;&gt;= -&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b3933a;&quot;&gt;1.2&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#668f14;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; b: PositiveFiniteFloat &lt;&#x2F;span&gt;&lt;span style=&quot;color:#72ab00;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; a.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b39f04;&quot;&gt;float_unwrap&lt;&#x2F;span&gt;&lt;span&gt;(); &lt;&#x2F;span&gt;&lt;span style=&quot;color:#7f8989;&quot;&gt;&#x2F;&#x2F; &amp;quot;Can&amp;#39;t convert negative float `-1.2` to positive number in line N&amp;quot;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Такие типы могли бы быть очень удобны во всяких библиотечных функциях. Например, функция расчёта площади треугольника по трём сторонам, которая принимает только конечные положительные числа, чтобы не &lt;strong&gt;валидировать&lt;&#x2F;strong&gt; их внутри:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#f5f5f5;color:#1f1f1f;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#668f14;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c23f31;&quot;&gt;triangle_area&lt;&#x2F;span&gt;&lt;span&gt;(
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#5597d6;&quot;&gt;a&lt;&#x2F;span&gt;&lt;span&gt;: PositiveNonZeroFiniteFloat, 
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#5597d6;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span&gt;: PositiveNonZeroFiniteFloat, 
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#5597d6;&quot;&gt;c&lt;&#x2F;span&gt;&lt;span&gt;: PositiveNonZeroFiniteFloat,
&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a2a001;&quot;&gt;Option&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;PositiveNonZeroFiniteFloat&amp;gt; { &lt;&#x2F;span&gt;&lt;span style=&quot;color:#7f8989;&quot;&gt;&#x2F;* ... *&#x2F; &lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#7f8989;&quot;&gt;&#x2F;&#x2F; В этой функции возвращается `Option&amp;lt;_&amp;gt;`, потому что в процессе вычислений может возникнуть бесконечность.
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;И таких способов расписать &lt;code&gt;NotNanFloat&lt;&#x2F;code&gt; существует очень много. Для этого, бы, наверное, в Rust пришлось создать целую языковую конструкцию &lt;code&gt;safe union&lt;&#x2F;code&gt;, которая позволяет переключаться между этими представлениями &lt;code&gt;Float&lt;&#x2F;code&gt;, потому что они абсолютно эквивалентны.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;to-zhe-samoe-no-na-tipakh&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#to-zhe-samoe-no-na-tipakh&quot;&gt;#&lt;&#x2F;a&gt;То же самое, но на типах&lt;&#x2F;h1&gt;
&lt;p&gt;Или это разделение можно записывать по-другому:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#f5f5f5;color:#1f1f1f;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#668f14;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c23f31;&quot;&gt;Yes&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#668f14;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c23f31;&quot;&gt;No&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#668f14;&quot;&gt;trait &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c23f31;&quot;&gt;IsFloatParameter &lt;&#x2F;span&gt;&lt;span&gt;{}
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#668f14;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;IsFloatParameter &lt;&#x2F;span&gt;&lt;span style=&quot;color:#72ab00;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c23f31;&quot;&gt;Yes&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c23f31;&quot;&gt;impl IsFloatParameter for No&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c23f31;&quot;&gt;struct Float&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;
&lt;&#x2F;span&gt;&lt;span&gt;    HasNan: IsFloatParameter,
&lt;&#x2F;span&gt;&lt;span&gt;    HasNegativeInfinity: IsFloatParameter,
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    HasNegativeFrom1: IsFloatParameter,
&lt;&#x2F;span&gt;&lt;span&gt;    HasNegative1: IsFloatParameter,
&lt;&#x2F;span&gt;&lt;span&gt;    HasNegativeFrom0To1: IsFloatParameter,
&lt;&#x2F;span&gt;&lt;span&gt;    HasNegative0: IsFloatParameter,
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    HasPositive0: IsFloatParameter,
&lt;&#x2F;span&gt;&lt;span&gt;    HasPositiveFrom0To1: IsFloatParameter,
&lt;&#x2F;span&gt;&lt;span&gt;    HasPositive1: IsFloatParameter,
&lt;&#x2F;span&gt;&lt;span&gt;    HasPositiveFrom1: IsFloatParameter,
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    HasPositiveInfinity: IsFloatParameter,
&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c23f31;&quot;&gt;f64&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c23f31;&quot;&gt;type NotNanFloat&lt;&#x2F;span&gt;&lt;span&gt; = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c23f31;&quot;&gt;Float&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;
&lt;&#x2F;span&gt;&lt;span&gt;    No, 
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    Yes, 
&lt;&#x2F;span&gt;&lt;span&gt;    Yes, Yes, Yes, Yes, 
&lt;&#x2F;span&gt;&lt;span&gt;    Yes, Yes, Yes, Yes, 
&lt;&#x2F;span&gt;&lt;span&gt;    Yes,
&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Но в таком случае теряется возможность матчиться по структуре данных, чтобы получить нужный промежуток. Не знаю что лучше.&lt;&#x2F;p&gt;
&lt;p&gt;Для подобного представления очень пригодятся умения программировать сложные вычисления на типах данных, чтобы автоматически получать все возможные преобразования для всех возможных комбинаций вещественных чисел.&lt;&#x2F;p&gt;
&lt;p&gt;Если же делать это вручную, то потребуется очень много кода. Вероятно, эту задачу было бы логичнее решать на зависимых типах? Или нужна новая, более сильная абстракция, чем ADT?&lt;&#x2F;p&gt;
&lt;h1 id=&quot;podderzhka-ot-kompiliatora&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#podderzhka-ot-kompiliatora&quot;&gt;#&lt;&#x2F;a&gt;Поддержка от компилятора&lt;&#x2F;h1&gt;
&lt;p&gt;Ещё, если такая система будет существовать, например, на Rust, то она должна поддерживаться со стороны компилятора аналогично &lt;code&gt;NonNull&lt;&#x2F;code&gt;, чтобы паттерн-матчинг по флоату раскрывался в максимально эффективные ассемблерные команды проверки, и чтобы хранение такого флоата в enum&#x27;ах &lt;code&gt;PositiveFloat&lt;&#x2F;code&gt;, &lt;code&gt;NotNanFloat&lt;&#x2F;code&gt; не тратило лишней памяти.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;zakliuchenie&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#zakliuchenie&quot;&gt;#&lt;&#x2F;a&gt;Заключение&lt;&#x2F;h1&gt;
&lt;p&gt;Наверное, поэтому даже в языках со статической типизацией, столько страданий приносят вещественные числа со своими бесконечностями и &lt;code&gt;NaN&lt;&#x2F;code&gt;&#x27;ами? Может быть, с этими типами данных, станет немного проще жить? Не знаю. Это лишь идея, возникающая на почве статической типизации головного мозга.&lt;&#x2F;p&gt;
&lt;p&gt;Динамическая типизация в JS легко сводится к статической типизации, потому что с логической точки зрения никакие операции над &lt;code&gt;int&lt;&#x2F;code&gt; не должны приводить к случайному возникновению &lt;code&gt;string&lt;&#x2F;code&gt;, а в вещественных числах всё сложнее, там все значения между собой очень сильно связаны, и вот простое сложение двух конечных чисел может дать бесконечность, а отношение двух конечных чисел может дать &lt;code&gt;NaN&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Надеюсь эта идея вдохновила вас.&lt;&#x2F;p&gt;
&lt;p&gt;А если хочется &lt;code&gt;NotNanFloat&lt;&#x2F;code&gt; иметь у себя в коде на Rust, то можно искать крейт по ключевым словам: &lt;code&gt;ordered float&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>Симметричные вероятности или Уверенности</title>
            <pubDate>Thu, 18 Jun 2020 00:00:00 +0000</pubDate>
            <link>https://testzorax.github.io/p/symmetric-probabilities/</link>
            <guid>https://testzorax.github.io/p/symmetric-probabilities/</guid>
            <description>&lt;h1 id=&quot;v-chiom-moia-problema&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#v-chiom-moia-problema&quot;&gt;#&lt;&#x2F;a&gt;В чём моя проблема?&lt;&#x2F;h1&gt;
&lt;p&gt;Я хочу иметь какие-то абстрактные чиселки рядом с правилами формальной грамматики, которые будут преобразовываться по каким-то абстрактным правилам (не обязательно умножение или сложение), для достижения каких-то целей.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;chto-za-tseli&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#chto-za-tseli&quot;&gt;#&lt;&#x2F;a&gt;Что за цели?&lt;&#x2F;h1&gt;
&lt;p&gt;Я пишу парсер при помощи которого будет аппроксимироваться естественный язык через Контекстно-Свободные грамматики. Очевидно, так как это аппроксимация, не может быть чего-то абсолютно верного и точного. Значит какие-то правила могут лучше аппроксимировать некоторые фразы, а какие-то хуже. Для этого мне нужны чиселки, чтобы они как-то преобразовывались, и чтобы на выходе получалось примерно такое: вот для этой фразы такой-то факт с вероятностью &lt;code&gt;57%&lt;&#x2F;code&gt; правильный, для такой-то фразы с вероятностью &lt;code&gt;98%&lt;&#x2F;code&gt; правильный. &lt;&#x2F;p&gt;
&lt;h1 id=&quot;pochemu-chiselki-abstraktnye-chto-tebe-nuzhno-ot-nikh&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#pochemu-chiselki-abstraktnye-chto-tebe-nuzhno-ot-nikh&quot;&gt;#&lt;&#x2F;a&gt;Почему чиселки абстрактные, что тебе нужно от них?&lt;&#x2F;h1&gt;
&lt;p&gt;Хотелось получить удобный интерфейс задания этих чиселок, который можно логически трактовать и который можно легко написать, будучи пользователем парсера (то есть без вмешательства численных методов).&lt;&#x2F;p&gt;
&lt;h1 id=&quot;nu-naprimer-sushchestvuiut-obychnye-veroiatnosti-chisla-ot-0-do-1-beri-ikh-da-umnozhai&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#nu-naprimer-sushchestvuiut-obychnye-veroiatnosti-chisla-ot-0-do-1-beri-ikh-da-umnozhai&quot;&gt;#&lt;&#x2F;a&gt;Ну, например, существуют обычные вероятности - числа от 0 до 1, бери их да, умножай.&lt;&#x2F;h1&gt;
&lt;p&gt;Нет. Обычные вероятности не подходят по нескольким причинам:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Чем больше фраза, тем больше умножений чисел от &lt;code&gt;0&lt;&#x2F;code&gt; до &lt;code&gt;1&lt;&#x2F;code&gt;, тем ближе результат к &lt;code&gt;0&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;В связи с этим абсолютные значения &amp;quot;вероятностей&amp;quot; не имеют никакого смысла.&lt;&#x2F;li&gt;
&lt;li&gt;Задавать их неудобно, нужны какие-то магические числа &lt;code&gt;0.57&lt;&#x2F;code&gt;, &lt;code&gt;0.98&lt;&#x2F;code&gt;, &lt;code&gt;0.05&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;Накладывается ограничение в виде того что сумма вероятностей для одного нетерминала должна быть &lt;code&gt;1&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;Смотри пример в &lt;a href=&quot;https:&#x2F;&#x2F;t.me&#x2F;optozorax_dev&#x2F;199&quot;&gt;&#x2F;199&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Вроде разъяснил, дальше продолжу обычное повествование.&lt;&#x2F;p&gt;
&lt;p&gt;В &lt;a href=&quot;https:&#x2F;&#x2F;t.me&#x2F;optozorax_dev&#x2F;184&quot;&gt;&#x2F;184&lt;&#x2F;a&gt; я предложил интерфейс описания &amp;quot;абстрактных чиселок&amp;quot;, который можно логично трактовать:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;+20%&lt;&#x2F;code&gt; - значит что-то увеличивается на что-то, увеличивается на число больше что больше чем &lt;code&gt;+10%&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;-20%&lt;&#x2F;code&gt; - аналогично верхнему уменьшается, и уменьшается сильнее, чем на &lt;code&gt;-10%&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;60%&lt;&#x2F;code&gt; - задаёт обычную вероятность&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Вскоре я понял что нельзя смешивать обычную вероятность и эти &lt;code&gt;+20%&lt;&#x2F;code&gt;, &lt;code&gt;-20%&lt;&#x2F;code&gt;. Потому что обычная вероятность их съедает, и вообще всё заражает собой.&lt;&#x2F;p&gt;
&lt;p&gt;Поэтому выкидываем её и добавляем элемент: &lt;code&gt;0%&lt;&#x2F;code&gt; - он означает, что ничего не изменится.&lt;&#x2F;p&gt;
&lt;p&gt;Назовём эту величину &amp;quot;уверенность&amp;quot;. И введём операцию объединения &amp;quot;уверенностей&amp;quot; под символом ★.&lt;&#x2F;p&gt;
&lt;p&gt;Теперь главная проблема состоит в том, чтобы определить как эти уверенности задавать, какие у них свойства и как вычислять ★.&lt;&#x2F;p&gt;
&lt;p&gt;Я решил что &lt;code&gt;-20%&lt;&#x2F;code&gt; должно мапиться в &lt;code&gt;-0.2&lt;&#x2F;code&gt;, &lt;code&gt;+20%&lt;&#x2F;code&gt; в &lt;code&gt;+0.2&lt;&#x2F;code&gt;, а в итоге область определения должна быть &lt;code&gt;[-1; 1]&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Я начал с создания &lt;a href=&quot;https:&#x2F;&#x2F;www.desmos.com&#x2F;calculator&#x2F;njsni62kej&quot;&gt;такой функции&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;div class=&quot;magnifier-container img-one&quot;&gt;
&lt;img
    class=&quot;not-default full-screen-img&quot;
    width=&quot;1280&quot;
    height=&quot;436&quot;
    src=&quot;&amp;#x2F;processed_images&amp;#x2F;6f6002d469d77b2300.webp&quot; 
    onclick=&quot;full_screen(&#x27;1.png&#x27;)&quot;
    onauxclick=&quot;full_screen_new_page(&#x27;1.png&#x27;)&quot;&gt;
&lt;div class=&quot;magnifier-display&quot;&gt;
&lt;img class=&quot;magnifier&quot; src=&quot;&#x2F;ico&#x2F;magnifier.svg&quot;&gt;&lt;div class=&quot;magnifier-info&quot;&gt;×1.2&lt;br&gt;png&lt;&#x2F;div&gt;
&lt;&#x2F;div&gt;
&lt;&#x2F;div&gt;
&lt;p&gt;Её проблема в том что она не гладкая, и она даёт разные результаты в зависимости от порядка когда её применять. А ведь в грамматиках не задан конкретный порядок, и не знаешь когда надо выполнить ★, а когда нет. К тому же она получала данные в области &lt;code&gt;[-1; 1]&lt;&#x2F;code&gt;, а возврщала в области &lt;code&gt;[0; 1]&lt;&#x2F;code&gt;. Но это легко поправляется.&lt;&#x2F;p&gt;
&lt;p&gt;Значит, самое главное свойство, которое мне нужно, это: (a ★ b) ★ c = (a ★ c) ★ b.&lt;&#x2F;p&gt;
&lt;p&gt;Далее я пытался гуглить, но безрезультатно. Пытался читать теорему Байеса, думать как её применить к своей задаче, тоже безрезультатно.&lt;&#x2F;p&gt;
&lt;p&gt;Затем я осознал, что я могу применить грубую силу!!! Я чёртов программист численных методов, я должен это использовать чтобы численно найти нужную мне функцию! &lt;&#x2F;p&gt;
&lt;p&gt;Итак, я должен был сделать следующую последовательность действий:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Сформулировать свойства необходимой мне функции&lt;&#x2F;li&gt;
&lt;li&gt;Запрограммировать расчёт выполнения этих свойств при помощи интегралов&lt;&#x2F;li&gt;
&lt;li&gt;Найти библиотеку для задания гладких 2D функций по каким-то числам&lt;&#x2F;li&gt;
&lt;li&gt;Использовать методы оптимизации, чтобы найти такие числа, которые на этих интегралах дают минимум&lt;&#x2F;li&gt;
&lt;li&gt;Достаточно оптимизировать и использовать&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Я думал что такой функции может не существовать, уж слишком хорошей она должна была быть.&lt;&#x2F;p&gt;
&lt;p&gt;Свойства я легко сформулировал, написал интеграл и начал тестировать. Моя линейная функция возвращала на этих свойствах 2. А идеальная функция должна 0. Самое плохое что там было - тройной интеграл для самого важного свойства (поэтому для точности с 10 точками требовалось 1000 вычислений функции).&lt;&#x2F;p&gt;
&lt;p&gt;Библиотеку для построения гладких 2D функций я не нашёл, поэтому пришлось применять свои знания с МКЭ, и самому программировать вычисление функции по числам-точкам.&lt;&#x2F;p&gt;
&lt;p&gt;Для методов оптимизации (нахождения минимума функции) я взял &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;argmin-rs&#x2F;argmin&quot;&gt;argmin-rs&lt;&#x2F;a&gt;. Советую квазиньютоновские методы.&lt;&#x2F;p&gt;
&lt;p&gt;Затем я совместил это всё с методами оптимизации и...&lt;&#x2F;p&gt;
&lt;p&gt;Оно работало очень долго. Для задания 2D функции я требовал слишком много параметров, и многие из них были избыточны, так что времени тратилась уйма. &lt;&#x2F;p&gt;
&lt;p&gt;Затем я понял, что нужна визуализация! А тут как раз &lt;a href=&quot;https:&#x2F;&#x2F;t.me&#x2F;dereference_pointer_there&#x2F;538&quot;&gt;Антон&lt;&#x2F;a&gt; рассказал про встраиваемый Питон в Rust! Немного повоевав с ним, я смог вывести получающуюся функцию через &lt;code&gt;matplotlib&lt;&#x2F;code&gt;, и даже &lt;code&gt;plt.show()&lt;&#x2F;code&gt; работало!&lt;&#x2F;p&gt;
&lt;p&gt;Я вывел график, и...&lt;&#x2F;p&gt;
&lt;div class=&quot;magnifier-container img-one&quot;&gt;
&lt;img
    class=&quot;not-default full-screen-img&quot;
    width=&quot;642&quot;
    height=&quot;542&quot;
    src=&quot;&amp;#x2F;processed_images&amp;#x2F;bddb2c25aad133ca00.webp&quot; 
    onclick=&quot;full_screen(&#x27;bad.jpg&#x27;)&quot;
    onauxclick=&quot;full_screen_new_page(&#x27;bad.jpg&#x27;)&quot;&gt;
&lt;div class=&quot;magnifier-display&quot;&gt;
&lt;img class=&quot;magnifier&quot; src=&quot;&#x2F;ico&#x2F;magnifier.svg&quot;&gt;&lt;div class=&quot;magnifier-info&quot;&gt;×1&lt;br&gt;jpg&lt;&#x2F;div&gt;
&lt;&#x2F;div&gt;
&lt;&#x2F;div&gt;
&lt;p&gt;Функция получалась... ужасная, она была очень шумной, не монотонной, явно переобучалась где-то. Ну и метрика кое-как доходила до &lt;code&gt;0.04&lt;&#x2F;code&gt;. Я ставил оптимизацию функции на несколько часов, и безрезультатно, в итоге у меня получалась полная чушь, да к тому же вырожденная, получалась функция, которая стремится сохранить первое значение.&lt;&#x2F;p&gt;
&lt;p&gt;Я сильно расстроился.&lt;&#x2F;p&gt;
&lt;p&gt;Но на следующий день мне пришло в голову, что на самом деле мои &amp;quot;веса&amp;quot; из &lt;a href=&quot;https:&#x2F;&#x2F;t.me&#x2F;optozorax_dev&#x2F;199&quot;&gt;&#x2F;199&lt;&#x2F;a&gt;, были очень даже подходящими! Они идеально подходили для отрезка от &lt;code&gt;0&lt;&#x2F;code&gt; до &lt;code&gt;1&lt;&#x2F;code&gt; и умножения &lt;code&gt;0.8&lt;&#x2F;code&gt; на &lt;code&gt;1.2&lt;&#x2F;code&gt;, но были неудобны для отрезка от &lt;code&gt;1&lt;&#x2F;code&gt; до &lt;code&gt;∞&lt;&#x2F;code&gt;. Тогда я решил просто сворачивать эту бесконечность до &lt;code&gt;1&lt;&#x2F;code&gt; путём деления. Тогда &lt;code&gt;+20%&lt;&#x2F;code&gt; превращалось в &lt;code&gt;1+1&#x2F;(1-0.2)=2.25&lt;&#x2F;code&gt;. И знаете что? Я получил идеальную функцию, которую хотел! Она идеально удовлетворяла всем свойствам и была очень даже гладкой. А ещё она симметричная: от &lt;code&gt;-1&lt;&#x2F;code&gt; до &lt;code&gt;0&lt;&#x2F;code&gt; ведёт себя так же как от &lt;code&gt;0&lt;&#x2F;code&gt; до &lt;code&gt;1&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Эх, так просто. А я даже не верил что она существует.&lt;&#x2F;p&gt;
&lt;div class=&quot;magnifier-container img-one&quot;&gt;
&lt;img
    class=&quot;not-default full-screen-img&quot;
    width=&quot;1060&quot;
    height=&quot;377&quot;
    src=&quot;&amp;#x2F;processed_images&amp;#x2F;7457597ac35567e100.webp&quot; 
    onclick=&quot;full_screen(&#x27;good.jpg&#x27;)&quot;
    onauxclick=&quot;full_screen_new_page(&#x27;good.jpg&#x27;)&quot;&gt;
&lt;div class=&quot;magnifier-display&quot;&gt;
&lt;img class=&quot;magnifier&quot; src=&quot;&#x2F;ico&#x2F;magnifier.svg&quot;&gt;&lt;div class=&quot;magnifier-info&quot;&gt;×1&lt;br&gt;jpg&lt;&#x2F;div&gt;
&lt;&#x2F;div&gt;
&lt;&#x2F;div&gt;
&lt;p&gt;Вот она, моя идеальная функция ❤️&lt;&#x2F;p&gt;
&lt;p&gt;А покрутить её можно &lt;a href=&quot;https:&#x2F;&#x2F;www.desmos.com&#x2F;calculator&#x2F;nadaxdx40e&quot;&gt;здесь&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Результат я опубликовал здесь: &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;optozorax&#x2F;confidence&quot;&gt;github:confidence&lt;&#x2F;a&gt;, старался написать код очень красиво и безопасно. В итоге понял, float - это динамическая типизация на уровне процессора, и я хочу чтобы он был на алгебраических типах данных)))0)&lt;&#x2F;p&gt;
&lt;p&gt;Но это уже совсем другая история, и тема следующего поста...&lt;&#x2F;p&gt;
&lt;h1 id=&quot;otrezok-1-1&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#otrezok-1-1&quot;&gt;#&lt;&#x2F;a&gt;Отрезок [-1, 1]&lt;&#x2F;h1&gt;
&lt;p&gt;Вообще я очень люблю отрезок &lt;code&gt;[-1, 1]&lt;&#x2F;code&gt;. &lt;&#x2F;p&gt;
&lt;p&gt;Год назад, когда я писал &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;optozorax&#x2F;labs_emf&#x2F;blob&#x2F;72e893134ee23ff39607e02c94b3a30d05cd4a53&#x2F;coursework&#x2F;report&#x2F;report.pdf&quot;&gt;курсовую&lt;&#x2F;a&gt; по &lt;a href=&quot;https:&#x2F;&#x2F;ru.wikipedia.org&#x2F;wiki&#x2F;%D0%9C%D0%B5%D1%82%D0%BE%D0%B4_%D0%BA%D0%BE%D0%BD%D0%B5%D1%87%D0%BD%D1%8B%D1%85_%D1%8D%D0%BB%D0%B5%D0%BC%D0%B5%D0%BD%D1%82%D0%BE%D0%B2&quot;&gt;МКЭ&lt;&#x2F;a&gt;, мне нужно было провести исследование того насколько хорошо метод работает на неравномерных квадратных сетках, построить графики или таблицы.&lt;&#x2F;p&gt;
&lt;p&gt;Если вы не знаете что такое неравномерная сетка, то вот иллюстрация (которую я нарисовал &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;optozorax&#x2F;bufdraw&#x2F;blob&#x2F;b466ecf8e3aa8936fc410809b3644462004fa46e&#x2F;examples&#x2F;grid.rs&quot;&gt;кодом&lt;&#x2F;a&gt;). Свойство этой сетки в том, что каждый следующий элемент больше другого в &lt;code&gt;c&lt;&#x2F;code&gt; раз, где &lt;code&gt;c&lt;&#x2F;code&gt; - какое-то положительное число от &lt;code&gt;0&lt;&#x2F;code&gt; до &lt;code&gt;∞&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;div class=&quot;magnifier-container img-one&quot;&gt;
&lt;img
    class=&quot;not-default full-screen-img&quot;
    width=&quot;900&quot;
    height=&quot;390&quot;
    src=&quot;&amp;#x2F;processed_images&amp;#x2F;c0f22f2615f12af100.webp&quot; 
    onclick=&quot;full_screen(&#x27;grid.jpg&#x27;)&quot;
    onauxclick=&quot;full_screen_new_page(&#x27;grid.jpg&#x27;)&quot;&gt;
&lt;div class=&quot;magnifier-display&quot;&gt;
&lt;img class=&quot;magnifier&quot; src=&quot;&#x2F;ico&#x2F;magnifier.svg&quot;&gt;&lt;div class=&quot;magnifier-info&quot;&gt;×1&lt;br&gt;jpg&lt;&#x2F;div&gt;
&lt;&#x2F;div&gt;
&lt;&#x2F;div&gt;
&lt;p&gt;Все обычно строили таблицы, где брали несколько неравномерных сеток и точности на ней, и делали какие-то выводы. А я грёбаный перфекционист, я заставлял компьютер трудиться не покладая транзисторов, и поэтому перебирал с очень маленьким шагом всё что можно, и строил графики через латех.&lt;&#x2F;p&gt;
&lt;p&gt;Сначала я, как и все задавал число c от &lt;code&gt;0&lt;&#x2F;code&gt; до &lt;code&gt;∞&lt;&#x2F;code&gt;. Получается, чем ближе c к нулю, тем сгущённей сетка к правому краю, а чем ближе она к бесконечности, тем сгущённей к левому.&lt;&#x2F;p&gt;
&lt;p&gt;Но проводить исследования на чём-то до бесконечности не удобно, взгляните на этот график:&lt;&#x2F;p&gt;
&lt;div class=&quot;magnifier-container img-one&quot;&gt;
&lt;img
    class=&quot;not-default full-screen-img&quot;
    width=&quot;841&quot;
    height=&quot;380&quot;
    src=&quot;&amp;#x2F;processed_images&amp;#x2F;5e3debe8697ea3f800.webp&quot; 
    onclick=&quot;full_screen(&#x27;graph1.jpg&#x27;)&quot;
    onauxclick=&quot;full_screen_new_page(&#x27;graph1.jpg&#x27;)&quot;&gt;
&lt;div class=&quot;magnifier-display&quot;&gt;
&lt;img class=&quot;magnifier&quot; src=&quot;&#x2F;ico&#x2F;magnifier.svg&quot;&gt;&lt;div class=&quot;magnifier-info&quot;&gt;×1&lt;br&gt;jpg&lt;&#x2F;div&gt;
&lt;&#x2F;div&gt;
&lt;&#x2F;div&gt;
&lt;p&gt;Где мне здесь остановиться? На &lt;code&gt;10^5&lt;&#x2F;code&gt;? На &lt;code&gt;10^10&lt;&#x2F;code&gt;? Делать экспоненциальное возрастание икса и логарифмическую шкалу? Непонятно. Тем более это очень неудобно логически воспринимать: несимметрично право и лево как-то получается.&lt;&#x2F;p&gt;
&lt;p&gt;Тогда я принял решение придумать такую функцию, которая позволяет задавать неравномерные сетки очень удобно, чтобы для значения коэффициента -1, сетка сгущалась к левому краю, а при значении коэффициента 1 сетка сгущалась к правому краю.&lt;&#x2F;p&gt;
&lt;div class=&quot;magnifier-container img-one&quot;&gt;
&lt;img
    class=&quot;not-default full-screen-img&quot;
    width=&quot;1046&quot;
    height=&quot;709&quot;
    src=&quot;&amp;#x2F;processed_images&amp;#x2F;c9d0f7e18f5a189f00.webp&quot; 
    onclick=&quot;full_screen(&#x27;text.jpg&#x27;)&quot;
    onauxclick=&quot;full_screen_new_page(&#x27;text.jpg&#x27;)&quot;&gt;
&lt;div class=&quot;magnifier-display&quot;&gt;
&lt;img class=&quot;magnifier&quot; src=&quot;&#x2F;ico&#x2F;magnifier.svg&quot;&gt;&lt;div class=&quot;magnifier-info&quot;&gt;×1&lt;br&gt;jpg&lt;&#x2F;div&gt;
&lt;&#x2F;div&gt;
&lt;&#x2F;div&gt;
&lt;p&gt;Придумал и &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;optozorax&#x2F;labs_emf&#x2F;blob&#x2F;72e893134ee23ff39607e02c94b3a30d05cd4a53&#x2F;coursework&#x2F;report&#x2F;file.tex#L503-L521&quot;&gt;описал&lt;&#x2F;a&gt; в отчёте.&lt;&#x2F;p&gt;
&lt;p&gt;А вот так офигенно выглядят исследования где одновременно меняется параметр сетки по осям &lt;code&gt;X&lt;&#x2F;code&gt; и &lt;code&gt;Y&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;div class=&quot;container&quot;&gt;
&lt;div class=&quot;magnifier-container img-one-two&quot;&gt;
&lt;img
    class=&quot;not-default full-screen-img&quot;
    width=&quot;640&quot;
    height=&quot;480&quot;
    src=&quot;&amp;#x2F;processed_images&amp;#x2F;470cbfaf1af290f900.webp&quot; 
    onclick=&quot;full_screen(&#x27;1.jpg&#x27;)&quot;
    onauxclick=&quot;full_screen_new_page(&#x27;1.jpg&#x27;)&quot;&gt;
&lt;div class=&quot;magnifier-display&quot;&gt;
&lt;img class=&quot;magnifier&quot; src=&quot;&#x2F;ico&#x2F;magnifier.svg&quot;&gt;&lt;div class=&quot;magnifier-info&quot;&gt;×2&lt;br&gt;jpg&lt;&#x2F;div&gt;
&lt;&#x2F;div&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;magnifier-container img-one-two&quot;&gt;
&lt;img
    class=&quot;not-default full-screen-img&quot;
    width=&quot;640&quot;
    height=&quot;480&quot;
    src=&quot;&amp;#x2F;processed_images&amp;#x2F;e42e4b861f07502100.webp&quot; 
    onclick=&quot;full_screen(&#x27;2.jpg&#x27;)&quot;
    onauxclick=&quot;full_screen_new_page(&#x27;2.jpg&#x27;)&quot;&gt;
&lt;div class=&quot;magnifier-display&quot;&gt;
&lt;img class=&quot;magnifier&quot; src=&quot;&#x2F;ico&#x2F;magnifier.svg&quot;&gt;&lt;div class=&quot;magnifier-info&quot;&gt;×2&lt;br&gt;jpg&lt;&#x2F;div&gt;
&lt;&#x2F;div&gt;
&lt;&#x2F;div&gt;
&lt;&#x2F;div&gt;</description>
        </item>
        <item>
            <title>Обозначения для линейной алгебры</title>
            <pubDate>Sat, 09 Nov 2019 00:00:00 +0000</pubDate>
            <link>https://testzorax.github.io/p/linear-algebra/</link>
            <guid>https://testzorax.github.io/p/linear-algebra/</guid>
            <description>&lt;h1 id=&quot;vvedenie&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#vvedenie&quot;&gt;#&lt;&#x2F;a&gt;Введение&lt;&#x2F;h1&gt;
&lt;p&gt;Знаете же эту байку, что после внедрения арабских цифр вместо римских, развитие математики пошло семимильными шагами?&lt;&#x2F;p&gt;
&lt;p&gt;Из этой байки можно сделать вывод, что иногда хорошая система обозначений или кодировки чего-то, может оказывать значительное влияние на то, как люди это воспринимают и насколько легко могут этим оперировать.&lt;&#x2F;p&gt;
&lt;p&gt;В данной статье рассказывается об обозначениях для базисов, векторов и линейных операторов, при помощи которых можно намного лучше понимать что же, чёрт возьми, происходит в линейной алгебре.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;abstraktnyi-vektor&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#abstraktnyi-vektor&quot;&gt;#&lt;&#x2F;a&gt;Абстрактный вектор&lt;&#x2F;h1&gt;
&lt;script type=&quot;math&#x2F;tex&quot;&gt;&lt;&#x2F;script&gt;
&lt;p&gt;Со школы мы привыкли, что вектор - это набор &lt;strong&gt;чисел&lt;&#x2F;strong&gt; &lt;script type=&quot;math&#x2F;tex&quot;&gt;\mathbf{x} = (1, 2, 3)^T&lt;&#x2F;script&gt;. Но в линейной алгебре любой вектор - это &lt;em&gt;абстрактный объект&lt;&#x2F;em&gt;, обладающий определёнными свойствами. &lt;&#x2F;p&gt;
&lt;p&gt;Например у нас может быть два вектора: &lt;script type=&quot;math&#x2F;tex&quot;&gt;\mathbf{x} =&lt;&#x2F;script&gt;апельсиновый сок, &lt;script type=&quot;math&#x2F;tex&quot;&gt;\mathbf{y}=&lt;&#x2F;script&gt; яблочный сок. И тогда результатом их суммы может быть: &lt;script type=&quot;math&#x2F;tex&quot;&gt;\mathbf{x}+2\mathbf{y}=&lt;&#x2F;script&gt;однояблочно-двуапельсиновый сок.&lt;&#x2F;p&gt;
&lt;p&gt;Свойства вектора задаются определением &lt;a href=&quot;https:&#x2F;&#x2F;ru.wikipedia.org&#x2F;wiki&#x2F;%D0%92%D0%B5%D0%BA%D1%82%D0%BE%D1%80%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D1%81%D1%82%D1%80%D0%B0%D0%BD%D1%81%D1%82%D0%B2%D0%BE&quot;&gt;линейного пространства&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;oboznacheniia&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#oboznacheniia&quot;&gt;#&lt;&#x2F;a&gt;Обозначения&lt;&#x2F;h1&gt;
&lt;p&gt;При помощи долларов будет обозначаться, как это пишется в &lt;code&gt;TeX&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Число&lt;&#x2F;strong&gt; - маленькая буква, обычный шрифт, &lt;code&gt;$x$&lt;&#x2F;code&gt;, &lt;code&gt;$y$&lt;&#x2F;code&gt;, &lt;code&gt;$z$&lt;&#x2F;code&gt;: &lt;script type=&quot;math&#x2F;tex&quot;&gt;x&lt;&#x2F;script&gt;, &lt;script type=&quot;math&#x2F;tex&quot;&gt;y&lt;&#x2F;script&gt;, &lt;script type=&quot;math&#x2F;tex&quot;&gt;z&lt;&#x2F;script&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Абстрактный вектор&lt;&#x2F;strong&gt; - маленькая буква, жирным прямым шрифтом, &lt;code&gt;$\mathbf{x}$&lt;&#x2F;code&gt;: &lt;script type=&quot;math&#x2F;tex&quot;&gt;\mathbf{x}&lt;&#x2F;script&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Базис&lt;&#x2F;strong&gt; - маленькая буква, ажурным шрифтом, &lt;code&gt;$\mathbb{e}$&lt;&#x2F;code&gt;: 𝕖. Является вектор-строкой из абстрактных векторов:&lt;&#x2F;p&gt;
&lt;script type=&quot;math&#x2F;tex;mode=display&quot;&gt;𝕖=(\mathbf{e}_1, \mathbf{e}_2, \dots, \mathbf{e}_n)&lt;&#x2F;script&gt;
&lt;p&gt;&lt;strong&gt;Линейный оператор&lt;&#x2F;strong&gt; - большая буква, жирным шрифтом, &lt;code&gt;$\mathbf{A}$&lt;&#x2F;code&gt;: &lt;script type=&quot;math&#x2F;tex&quot;&gt;\mathbf{A}(\mathbf{x})&lt;&#x2F;script&gt;, обязательно использование скобок после него.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Численный вектор&lt;&#x2F;strong&gt; - абстрактный вектор, заключённый в квадратные скобки, и с дописанным снизу базисом, куда он спроецирован, &lt;code&gt;$[\mathbf{x}]_\mathbb{e}$&lt;&#x2F;code&gt;: &lt;script type=&quot;math&#x2F;tex&quot;&gt;[\mathbf{x}]_𝕖&lt;&#x2F;script&gt;. Это вектор &lt;script type=&quot;math&#x2F;tex&quot;&gt;\mathbf{x}&lt;&#x2F;script&gt; в базисе &lt;script type=&quot;math&#x2F;tex&quot;&gt;𝕖&lt;&#x2F;script&gt;. Является вектор-столбцом чисел.&lt;&#x2F;p&gt;
&lt;script type=&quot;math&#x2F;tex;mode=display&quot;&gt;[\mathbf{x}]_𝕖 = 
\begin{pmatrix}
	x_1\\
	x_2\\
	\ldots\\
	x_n
\end{pmatrix}&lt;&#x2F;script&gt;
&lt;p&gt;Любой абстрактный вектор можно представить в виде:&lt;&#x2F;p&gt;
&lt;script type=&quot;math&#x2F;tex;mode=display&quot;&gt;\mathbf{x} = 𝕖\cdot [\mathbf{x}]_𝕖&lt;&#x2F;script&gt;
&lt;script type=&quot;math&#x2F;tex;mode=display&quot;&gt;\mathbf{x} = (\mathbf{e}_1, \mathbf{e}_2, \dots, \mathbf{e}_n)\cdot\begin{pmatrix}
	x_1\\
	x_2\\
	\ldots\\
	x_n
\end{pmatrix}&lt;&#x2F;script&gt;
&lt;script type=&quot;math&#x2F;tex;mode=display&quot;&gt;\mathbf{x} = x_1\mathbf{e}_1 + x_2\mathbf{e}_2 + \dots + x_n\mathbf{e}_n&lt;&#x2F;script&gt;
&lt;p&gt;Эти формулы задают соответствие между абстрактным и численными векторами!&lt;&#x2F;p&gt;
&lt;p&gt;Заметьте, что можно ввести базис &lt;script type=&quot;math&#x2F;tex&quot;&gt;𝕒=(\mathbf{a}_1, \mathbf{a}_2, \dots, \mathbf{a}_n)&lt;&#x2F;script&gt;. Тогда можно записать вектор &lt;script type=&quot;math&#x2F;tex&quot;&gt;\mathbf{x}&lt;&#x2F;script&gt; через этот базис:&lt;&#x2F;p&gt;
&lt;script type=&quot;math&#x2F;tex;mode=display&quot;&gt;\mathbf{x} = 𝕒\cdot [\mathbf{x}]_𝕒&lt;&#x2F;script&gt;
&lt;p&gt;И в другом базисе будут другие числа, но вектор останется одним и тем же. Конечно, на практике мы никогда не столкнёмся с абстрактными векторами, а всегда будем работать с числовыми столбцами, но это удобная абстракция, чтобы обозначить один и тот же объект.&lt;&#x2F;p&gt;
&lt;p&gt;По сути численный вектор - это &lt;em&gt;проекция&lt;&#x2F;em&gt; абстрактного вектора на базис.&lt;&#x2F;p&gt;
&lt;p&gt;Кстати, линейные операции над вектором равносильны линейным операциям над его координатным столбцом:&lt;&#x2F;p&gt;
&lt;script type=&quot;math&#x2F;tex;mode=display&quot;&gt;[c\cdot \mathbf{x}]_𝕖 = c\cdot [\mathbf{x}]_𝕖 &lt;&#x2F;script&gt;
&lt;script type=&quot;math&#x2F;tex;mode=display&quot;&gt;\displaystyle [\mathbf{x} + \mathbf{y}]_𝕖 = [\mathbf{x}]_𝕖 + [\mathbf{y}]_𝕖 &lt;&#x2F;script&gt;
&lt;h1 id=&quot;perekhod-iz-odnogo-bazisa-v-drugoi&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#perekhod-iz-odnogo-bazisa-v-drugoi&quot;&gt;#&lt;&#x2F;a&gt;Переход из одного базиса в другой&lt;&#x2F;h1&gt;
&lt;p&gt;В этой задаче данные обозначения проявляют свою силу, потому что со стандартными обозначениями в ней происходит больше всего путаницы при решении задач.&lt;&#x2F;p&gt;
&lt;p&gt;Скажем, мы смогли выразить вектора базиса &lt;script type=&quot;math&#x2F;tex&quot;&gt;𝕒&lt;&#x2F;script&gt; через вектора базиса &lt;script type=&quot;math&#x2F;tex&quot;&gt;𝕖&lt;&#x2F;script&gt;:&lt;&#x2F;p&gt;
&lt;script type=&quot;math&#x2F;tex;mode=display&quot;&gt;
\left\{
\begin{aligned}
	&amp;\mathbf{a_1} = 𝕖 \cdot [a_1]_𝕖 = \alpha_{1,1}\mathbf{e_1} + \alpha_{1,2}\mathbf{e_2} + \ldots + \alpha_{1,n}\mathbf{e_n} \\
	&amp;\mathbf{a_2} = 𝕖 \cdot [a_2]_𝕖 = \alpha_{2,1}\mathbf{e_1} + \alpha_{2,2}\mathbf{e_2} + \ldots + \alpha_{2,n}\mathbf{e_n} \\
	&amp;\ldots \\
	&amp;\mathbf{a_n} = 𝕖 \cdot [a_n]_𝕖 = \alpha_{n,1}\mathbf{e_1} + \alpha_{n,2}\mathbf{e_2} + \ldots + \alpha_{n,n}\mathbf{e_n}
\end{aligned}
\right.
&lt;&#x2F;script&gt;
&lt;p&gt;И ввёдем такую матрицу:&lt;&#x2F;p&gt;
&lt;script type=&quot;math&#x2F;tex;mode=display&quot;&gt;
P_{𝕖𝕒} = 
\left([a_1]_𝕖, [a_2]_𝕖, \ldots, [a_n]_𝕖\right)
&lt;&#x2F;script&gt;
&lt;script type=&quot;math&#x2F;tex;mode=display&quot;&gt;
P_{𝕖𝕒} = 
\begin{pmatrix}
	\alpha_{1,1}&amp; \alpha_{2, 1}&amp; \ldots&amp; \alpha_{n,1} \\
	\alpha_{1,2}&amp; \alpha_{2, 2}&amp; \ldots&amp; \alpha_{n,2} \\
	\ldots&amp; \ldots&amp; \ldots&amp; \ldots \\
	\alpha_{1,n}&amp; \alpha_{2, n}&amp; \ldots&amp; \alpha_{n,n}
\end{pmatrix}
&lt;&#x2F;script&gt;
&lt;p&gt;Тогда изначальная система равносильна следующим записям:&lt;&#x2F;p&gt;
&lt;script type=&quot;math&#x2F;tex;mode=display&quot;&gt;
\begin{matrix}
	&amp;P_{𝕖𝕒}^T \cdot 𝕖^T &amp;= &amp;𝕒^T \\
	&amp;𝕖 \cdot P_{𝕖𝕒} &amp;= &amp;𝕒 \\
	&amp;𝕒 \cdot P_{𝕖𝕒}^{-1} &amp;= &amp;𝕖 \\
	&amp;𝕒 \cdot P_{𝕒𝕖} &amp;= &amp;𝕖
\end{matrix}
&lt;&#x2F;script&gt;
&lt;script type=&quot;math&#x2F;tex&quot;&gt;P_{𝕖𝕒}&lt;&#x2F;script&gt; называется матрицей перехода от базиса 𝕖 к базису 𝕒.
&lt;p&gt;Из имеющихся у нас формул можно вывести ещё несколько полезных:&lt;&#x2F;p&gt;
&lt;script type=&quot;math&#x2F;tex;mode=display&quot;&gt; P_{𝕖𝕒} = P_{𝕒𝕖}^{-1} &lt;&#x2F;script&gt;
&lt;script type=&quot;math&#x2F;tex;mode=display&quot;&gt; 𝕒 = 𝕖 \cdot P_{𝕖𝕒} &lt;&#x2F;script&gt;
&lt;script type=&quot;math&#x2F;tex;mode=display&quot;&gt; P_{𝕒𝕕} = P_{𝕒𝕖}\cdot P_{𝕖𝕕} &lt;&#x2F;script&gt;
&lt;script type=&quot;math&#x2F;tex;mode=display&quot;&gt; [\mathbf{x}]_𝕒 = P_{𝕖𝕒} \cdot [\mathbf{x}]_𝕖 &lt;&#x2F;script&gt;
&lt;p&gt;Благодаря полученным формулам мы теперь знаем как переводить численные вектора из одного базиса в другой.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;lineinyi-operator&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#lineinyi-operator&quot;&gt;#&lt;&#x2F;a&gt;Линейный оператор&lt;&#x2F;h1&gt;
&lt;p&gt;&lt;strong&gt;Линейный оператор&lt;&#x2F;strong&gt; - это функция, принимающая на вход вектор, и возвращающая вектор. При этом пространство первого вектора может отличаться от пространства второго вектора. &lt;&#x2F;p&gt;
&lt;p&gt;В математике любят писать: &lt;script type=&quot;math&#x2F;tex&quot;&gt;\mathbf{A}\mathbf{x}&lt;&#x2F;script&gt;, что означает, что &amp;quot;оператор применяется к вектору&amp;quot;. Меня эта нотация бесит. Она похожа на умножение, и всегда надо заранее знать, что &lt;script type=&quot;math&#x2F;tex&quot;&gt;\mathbf{A}&lt;&#x2F;script&gt; - функция.&lt;&#x2F;p&gt;
&lt;p&gt;Этот &amp;quot;оператор&amp;quot; называется &lt;em&gt;линейным&lt;&#x2F;em&gt;, потому что он обладает линейными свойствами (как и практически всё в линейной алгебре).&lt;&#x2F;p&gt;
&lt;script type=&quot;math&#x2F;tex;mode=display&quot;&gt;\mathbf{A}(\mathbf{x} + \mathbf{y}) = \mathbf{A}(\mathbf{x}) + \mathbf{A}(\mathbf{y})&lt;&#x2F;script&gt;
&lt;script type=&quot;math&#x2F;tex;mode=display&quot;&gt;\mathbf{A}(c\cdot\mathbf{x}) = c\cdot\mathbf{A}(\mathbf{x})&lt;&#x2F;script&gt;
&lt;p&gt;Чем же является линейный оператор в нашем мире чисел? Оказывается, можно доказать, что любой линейный оператор для данных базисов можно свести к единственной матрице! При этом операция &amp;quot;применения оператора к вектору&amp;quot; будет являться умножением матрицы на этот вектор. &lt;&#x2F;p&gt;
&lt;script type=&quot;math&#x2F;tex;mode=display&quot;&gt;
[\mathbf{A}]_{𝕖𝕒}\cdot[\mathbf{x}]_𝕖 = [\mathbf{y}]_𝕒
&lt;&#x2F;script&gt;
&lt;p&gt;Именно из-за этого я стараюсь не использовать применения оператора без скобочек, потому что у нас появляется ещё больше шансов спутать абстрактный оператор с матрицей.&lt;&#x2F;p&gt;
&lt;p&gt;Заметьте, что матрица зависит от двух базисов: от входных данных и от результатов! Ведь результат может быть 50-мерный вектор, а вход - 2-мерный. Конечно, на практике чаще встречается, что вход и выход находятся в одном базисе и следовательно имеют одинаковую размерность. Поэтому покажу обозначение именно для этого случая:&lt;&#x2F;p&gt;
&lt;script type=&quot;math&#x2F;tex;mode=display&quot;&gt;
[\mathbf{A}]_𝕖\cdot[\mathbf{x}]_𝕖 = [\mathbf{y}]_𝕖
&lt;&#x2F;script&gt;
&lt;p&gt;Ещё раз подчеркну, линейный оператор ≠ матрице линейного оператора. &lt;&#x2F;p&gt;
&lt;p&gt;Линейный оператор - это абстрактная функция, а матрица - это конкретная её реализация в виде набора чисел.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;vyvod-formuly-perevoda-matritsy-lineinogo-operatora&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#vyvod-formuly-perevoda-matritsy-lineinogo-operatora&quot;&gt;#&lt;&#x2F;a&gt;Вывод формулы перевода матрицы линейного оператора&lt;&#x2F;h1&gt;
&lt;p&gt;Скажем, мы знаем как линейный оператор представляется в пространстве &lt;script type=&quot;math&#x2F;tex&quot;&gt;𝕖&lt;&#x2F;script&gt;:&lt;&#x2F;p&gt;
&lt;script type=&quot;math&#x2F;tex;mode=display&quot;&gt;[\mathbf{A}]_𝕖\cdot[\mathbf{x}]_𝕖 = [\mathbf{y}]_𝕖&lt;&#x2F;script&gt;
&lt;p&gt;И нам нужно получить его матрицу в базисе &lt;script type=&quot;math&#x2F;tex&quot;&gt;𝕒&lt;&#x2F;script&gt;, то есть такую матрицу, чтобы выполнялось следующее равенство:&lt;&#x2F;p&gt;
&lt;script type=&quot;math&#x2F;tex;mode=display&quot;&gt;[\mathbf{A}]_𝕒\cdot[\mathbf{x}]_𝕒 = [\mathbf{y}]_𝕒&lt;&#x2F;script&gt;
&lt;p&gt;Тогда для вывода нам понадобится следующее:&lt;&#x2F;p&gt;
&lt;script type=&quot;math&#x2F;tex;mode=display&quot;&gt; [\mathbf{x}]_𝕖 = P_{𝕒𝕖} \cdot [\mathbf{x}]_𝕒 &lt;&#x2F;script&gt;
&lt;script type=&quot;math&#x2F;tex;mode=display&quot;&gt;[\mathbf{y}]_𝕖 = P_{𝕒𝕖} \cdot [\mathbf{y}]_𝕒&lt;&#x2F;script&gt;
&lt;script type=&quot;math&#x2F;tex;mode=display&quot;&gt;[\mathbf{A}]_𝕖\cdot[\mathbf{x}]_𝕖 = [\mathbf{y}]_𝕖&lt;&#x2F;script&gt;
&lt;p&gt;Подставляем первые две формулы в третью:&lt;&#x2F;p&gt;
&lt;script type=&quot;math&#x2F;tex;mode=display&quot;&gt;[\mathbf{A}]_𝕖\cdot P_{𝕒𝕖} \cdot [\mathbf{x}]_𝕒 = P_{𝕒𝕖} \cdot [\mathbf{y}]_𝕒&lt;&#x2F;script&gt;
&lt;script type=&quot;math&#x2F;tex;mode=display&quot;&gt;P_{𝕒𝕖}^{-1} \cdot [\mathbf{A}]_𝕖\cdot P_{𝕒𝕖} \cdot [\mathbf{x}]_𝕒 = [\mathbf{y}]_𝕒&lt;&#x2F;script&gt;
&lt;p&gt;И получаем такой ответ:&lt;&#x2F;p&gt;
&lt;script type=&quot;math&#x2F;tex;mode=display&quot;&gt;[\mathbf{A}]_𝕒 = P_{𝕒𝕖}^{-1} \cdot [\mathbf{A}]_𝕒\cdot P_{𝕒𝕖}&lt;&#x2F;script&gt;
&lt;h1 id=&quot;pochemu-eti-oboznacheniia-khoroshi&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#pochemu-eti-oboznacheniia-khoroshi&quot;&gt;#&lt;&#x2F;a&gt;Почему эти обозначения хороши?&lt;&#x2F;h1&gt;
&lt;p&gt;Вы могли заметить, что впервые в жизни поняли что происходит в этой чертовой линейной алгебре, и это неспроста. В стандартных обозначениях нет никакого разделения между вектором, его проекцией на базис, и базисом. Всё &lt;strong&gt;тупо&lt;&#x2F;strong&gt; и &lt;strong&gt;лениво&lt;&#x2F;strong&gt; обозначается обычными нежирными неажурными буквами. &lt;&#x2F;p&gt;
&lt;p&gt;Именно из-за этого тебе постоянно приходится помнить о контексте. И ещё хорошо, если тебе расскажут разницу между абстрактным вектором и числовым столбцом. Обычно преподаватели сами толком не знают разницу, или не знают что на неё надо обратить внимание студентов.&lt;&#x2F;p&gt;
&lt;p&gt;Минус тупого обозначения всего обычными буквами в том, что &lt;strong&gt;обычные буквы начинают обозначать слишком много&lt;&#x2F;strong&gt;. У них появляется многозначность. В зависимости от контекста &lt;script type=&quot;math&#x2F;tex&quot;&gt;a&lt;&#x2F;script&gt; мог быть чем угодно: числом, вектором, базисом и даже оператором младшим.&lt;&#x2F;p&gt;
&lt;p&gt;Соглашусь, что эта система обозначения координатных столцом слишком многосимвольна: для её написания требуется писать &lt;code&gt;[&lt;&#x2F;code&gt;, &lt;code&gt;]&lt;&#x2F;code&gt;, &lt;code&gt;𝕖&lt;&#x2F;code&gt;, а как писать последнее при помощи ручки вообще непонятно. Применять её на практике для решения задач в линейной алгебре невозможно. Поэтому я предлагаю использовать такие обозначения для:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Книг и методичек,&lt;&#x2F;li&gt;
&lt;li&gt;На бумаге, когда в задании фигурирует переход из одного базиса в другой,&lt;&#x2F;li&gt;
&lt;li&gt;На начальных этапах, чтобы различать абстрактный вектор и столбец чисел,&lt;&#x2F;li&gt;
&lt;li&gt;Когда забыл как всё работает.
Далее же, &lt;em&gt;когда научишься всё понимать&lt;&#x2F;em&gt;, можно использовать обычные буквы, для сокращения записей.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Данная система является немного доработанной системой обозначений, рассказанной &lt;a href=&quot;https:&#x2F;&#x2F;ciu.nstu.ru&#x2F;kaf&#x2F;persons&#x2F;3080&quot;&gt;Овчинниковой Еленой Викторовной&lt;&#x2F;a&gt; на факультете АВТ, университета НГТУ.&lt;&#x2F;p&gt;
&lt;p&gt;Главными фичами этой системы обозначений является:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Вектор разделён на два понятия: абстрактный и числовой.&lt;&#x2F;li&gt;
&lt;li&gt;Для каждого из классов придуманы особые обозначения.&lt;&#x2F;li&gt;
&lt;li&gt;Базис у числого вектора не игнорируется и находится в его обозначении.&lt;&#x2F;li&gt;
&lt;li&gt;Для базиса выбран особый шрифт, чтобы его нельзя было спутать с вектором или числом.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h1 id=&quot;vyvod&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#vyvod&quot;&gt;#&lt;&#x2F;a&gt;Вывод&lt;&#x2F;h1&gt;
&lt;center&gt;&lt;big&gt;Правильные обозначения важны.&lt;&#x2F;big&gt;&lt;&#x2F;center&gt;</description>
        </item>
    </channel>
</rss>
